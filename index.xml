<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JuananBlog</title>
    <link>https://juanan219.github.io/</link>
    <description>Recent content on JuananBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 26 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://juanan219.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sistema de copias de seguridad</title>
      <link>https://juanan219.github.io/posts/2021/05/sistema-de-copias-de-seguridad/</link>
      <pubDate>Wed, 26 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/05/sistema-de-copias-de-seguridad/</guid>
      <description>Voy a integrar un sistema de copias de seguridad en mi escenario de servidores, para ello voy a instalar y configurar bácula, así que para empezar vamos a explicar qué es bácula y de qué se compone.
¿Qué es bácula? Bácula es un sistema de copias de seguridad, el cual se compone de 3 servicios diferentes:
  Bacula director: Es el servicio que lo controla todo, es decir, el que le dice a cada servicio qué es lo que tiene que hacer.</description>
    </item>
    
    <item>
      <title>Despliegue de un cluster de Kubernetes</title>
      <link>https://juanan219.github.io/posts/2021/05/despliegue-de-un-cluster-de-kubernetes/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/05/despliegue-de-un-cluster-de-kubernetes/</guid>
      <description>Tengo 3 máquinas virtuales (master, nodo1 y nodo2), la máquina master es el controlador y los dos nodos son los workers.
Este escenario lo he montado en vagrant usando virtualbox, aquí está el Vagrantfile
Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.define :master do |master| master.vm.box = &amp;quot;debian/buster64&amp;quot; master.vm.hostname = &amp;quot;master&amp;quot; master.vm.network :public_network, :bridge=&amp;gt;&amp;quot;eno1&amp;quot; end config.vm.define :nodo1 do |nodo1| nodo1.vm.box = &amp;quot;debian/buster64&amp;quot; nodo1.vm.hostname = &amp;quot;nodo1&amp;quot; nodo1.vm.network :public_network, :bridge=&amp;gt;&amp;quot;eno1&amp;quot; end config.vm.define :nodo2 do |nodo2| nodo2.vm.box = &amp;quot;debian/buster64&amp;quot; nodo2.</description>
    </item>
    
    <item>
      <title>Metricas logs y monitorizacion</title>
      <link>https://juanan219.github.io/posts/2021/04/metricas-logs-y-monitorizacion/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/04/metricas-logs-y-monitorizacion/</guid>
      <description>Descripción del escenario En esta entrada vamos a montar el servicio de recolección de métricas para poder monitorizar nuestros servidores en una infraestructura de red. En esta infraestructura tenemos 4 servidores y 2 redes:
 Red 1 (10.0.1.0/24):  En esta red tenemos a:
  Dulcinea (Debian): Hace la función de router y cortafuegos.
  Sancho (Ubuntu): Es un servidor que solo tiene instalados gestores de bases de datos.</description>
    </item>
    
    <item>
      <title>Apuntes de Libvirt</title>
      <link>https://juanan219.github.io/posts/2021/03/apuntes-de-libvirt/</link>
      <pubDate>Thu, 18 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/03/apuntes-de-libvirt/</guid>
      <description>Libvirt es una API de virtualizacion que se usa con KVM o Qemu KVM (el sistema de virtualización nativo de Linux).
Instalación Para instalar libvirt deberemos instalar los siguientes paquetes
sudo apt-get install qemu-kvm libvirt-daemon-system Explicación de los paquetes:
  qemu-kvm: Proporciona la virtualización para x86
  libvirt-daemon-system: Es el demonio de libvirt, el cual hace accesible la API a través de un socket UNIX (aunque se puede configurar para acceder a través de un socket TCP).</description>
    </item>
    
    <item>
      <title>Practica VPN</title>
      <link>https://juanan219.github.io/posts/2021/03/practica-vpn/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/03/practica-vpn/</guid>
      <description>Tarea1: VPN de acceso remoto con OpenVNP y certificados x509 En esta tarea vamos a montar una VPN con OpenVPN con certificados x509 generados usando la herramienta easy-rsa, para ello vamos a hacer el uso de 3 máquinas:
 Mi máquina personal (Cliente) Servidor (Servidor VPN) Máquina de la red interna (Máquina a la que nos vamos a conectar)  Instalación de las herramientas Para realizar esta tarea vamos a necesitar instalar OpenVPN tanto en mi máquina como en el servidor</description>
    </item>
    
    <item>
      <title>Implantación de aplicaciones web PHP en Docker</title>
      <link>https://juanan219.github.io/posts/2021/03/implantaci%C3%B3n-de-aplicaciones-web-php-en-docker/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/03/implantaci%C3%B3n-de-aplicaciones-web-php-en-docker/</guid>
      <description>Tarea 1  Crea un script con docker-compose que levante el escenario con los dos contenedores.(Usuario: admin, contraseña: admin).  Para levantar la aplicación web bookmedik necesitaremos un contenedor con la imagen de mariadb en el cual vamos a crear un usuario llamado book_user con una contraseña book_passwd, una base de datos llamada bookmedik y le vamos a volcar el contenido del fichero schema.sql del repositorio de GitHub de bookmedik, del cual, vamos a eliminar la primera línea para que no nos de conflicto a la hora de ejecutar el script.</description>
    </item>
    
    <item>
      <title>Creación de Imagenes Docker</title>
      <link>https://juanan219.github.io/posts/2021/02/creaci%C3%B3n-de-imagenes-docker/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/02/creaci%C3%B3n-de-imagenes-docker/</guid>
      <description>Hasta ahora hemos usado imágenes de Docker que han hecho otras personas, pero para crear un contenedor que sirva nuestra aplicación, deberemos crear una imagen personalidada. A esto es a lo que llamamos dockerizar una aplicación.
Creación de una imagen a partir de un contenedor La primera forma de crear nuestras propias imágenes personalizadas es crearlas a partir de un contenedor que ya está en ejecución. Para ello tenemos varias posibilidades:</description>
    </item>
    
    <item>
      <title>Almacenamiento en Docker</title>
      <link>https://juanan219.github.io/posts/2021/02/almacenamiento-en-docker/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/02/almacenamiento-en-docker/</guid>
      <description>Los contenedores son efímeros Los contenedores de docker son efímeros, es decir, todo lo que generamos dentro de un contenedor resisten a las paradas de los contenedores, pero cuando eliminamos un contenedor, todo lo que hay en su interior se elimina con él. Veamos esto creando un contenedor y creando dentro de él un fichero, cuando lo eliminemos, crearemos otro contenedor para comprobar si ese archivo está
docker run --name docker_nginx -p 8080:80 -d nginx c45464659bca8dc80372f7fcbcf1fa8e2abdb7f3d68dd7eb46a22ef6d5cf824f docker exec docker_nginx bash -c &#39;echo &amp;quot;&amp;lt;h1&amp;gt;Esto es una prueba&amp;lt;/h1&amp;gt;&amp;quot; &amp;gt; /usr/share/nginx/html/index.</description>
    </item>
    
    <item>
      <title>Creando escenarios multicontenedor con docker-compose</title>
      <link>https://juanan219.github.io/posts/2021/02/creando-escenarios-multicontenedor-con-docker-compose/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/02/creando-escenarios-multicontenedor-con-docker-compose/</guid>
      <description>En ocasiones, es necesario disponer de múltiples contenedores, como por ejemplo:
  Cuando necesitamos varios servicios para que la aplicación funcione, como por ejemplo con Wordpress, necesitaríamos un contenedor para la propia aplicación web y otro contenedor para el servidor de bases de datos MySQL.
  Si tenemos nuestra aplicación construida con microservicios, de los cuales, cada microservicio se ejecutará en un contenedor independiente.
  Cuando trabajamos en escenarios en los que necesitamos varios contenedores, podemos usar docker-compose para gestionarlos.</description>
    </item>
    
    <item>
      <title>Uso de las Imagenes Docker</title>
      <link>https://juanan219.github.io/posts/2021/02/uso-de-las-imagenes-docker/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://juanan219.github.io/posts/2021/02/uso-de-las-imagenes-docker/</guid>
      <description>Registros de Imágenes: DockerHub Las imágenes de Docker son plantillas de solo lectura, es decir, una imagen que contiene archivos de un sistema operativo como Debian, solo nos permitirá crear contenedores basados en dicha imagen, pero los cambios que hagamos en el contenedor, una vez que se ha detenido, no se verán reflejados en la imagen.
El nombre de una imágen suele estar formado por tres partes:
usuario/nombre:etiqueta   usuario: El nombre del usuario que ha generado la imagen.</description>
    </item>
    
  </channel>
</rss>
