<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on JuananBlog</title>
        <link>https://juanan219.github.io/posts/</link>
        <description>Recent content in Posts on JuananBlog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 23 Feb 2021 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://juanan219.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Almacenamiento en Docker</title>
            <link>https://juanan219.github.io/posts/2021/02/almacenamiento-en-docker/</link>
            <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/almacenamiento-en-docker/</guid>
            <description>Los contenedores son ef√≠meros Los contenedores de docker son ef√≠meros, es decir, todo lo que generamos dentro de un contenedor resisten a las paradas de los contenedores, pero cuando eliminamos un contenedor, todo lo que hay en su interior se elimina con √©l. Veamos esto creando un contenedor y creando dentro de √©l un fichero, cuando lo eliminemos, crearemos otro contenedor para comprobar si ese archivo est√°
docker run --name docker_nginx -p 8080:80 -d nginx c45464659bca8dc80372f7fcbcf1fa8e2abdb7f3d68dd7eb46a22ef6d5cf824f docker exec docker_nginx bash -c &#39;echo &amp;quot;&amp;lt;h1&amp;gt;Esto es una prueba&amp;lt;/h1&amp;gt;&amp;quot; &amp;gt; /usr/share/nginx/html/index.</description>
            <content type="html"><![CDATA[<h2 id="los-contenedores-son-ef√≠meros">Los contenedores son ef√≠meros</h2>
<p>Los contenedores de docker <strong>son ef√≠meros</strong>, es decir, todo lo que generamos dentro de un contenedor resisten a las paradas de los contenedores, pero cuando eliminamos un contenedor, todo lo que hay en su interior se elimina con √©l. Veamos esto creando un contenedor y creando dentro de √©l un fichero, cuando lo eliminemos, crearemos otro contenedor para comprobar si ese archivo est√°</p>
<pre><code>docker run --name docker_nginx -p 8080:80 -d nginx
c45464659bca8dc80372f7fcbcf1fa8e2abdb7f3d68dd7eb46a22ef6d5cf824f

docker exec docker_nginx bash -c 'echo &quot;&lt;h1&gt;Esto es una prueba&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html'

curl 127.0.0.1:8080
&lt;h1&gt;Esto es una prueba&lt;/h1&gt;

docker rm -f docker_nginx
docker_nginx

docker run --name docker_nginx -p 8080:80 -d nginx
9168378ab8621adea4936a49d556ba999c8b54d29eeaf99f1eabc6d5a2c7553c

curl 127.0.0.1:8080
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Como podemos ver, el fichero que hab√≠amos creado anteriormente como <code>index.html</code> ha desaparecido y se ha sustituido por el fichero <code>index.html</code> predeterminado de <code>nginx</code>, esto quiere decir qu enuestro ficher se ha eliminado junto con el contenedor.</p>
<ul>
<li><strong>Explicaci√≥n:</strong> El comando que hemos usado para introducir el fichero contiene la opci√≥n <code>bash -c</code>, la cual nos permite ejecutar varias instrucciones de bash de forma m√°s compleja (por ejemplo indicando ficheros dentro del sistema).</li>
</ul>
<h2 id="los-datos-de-los-contenedores">Los datos de los contenedores</h2>
<p>Ante la anterior situaci√≥n, Docker nos proporciona varias formas de resolver este problema. Ahora veremos las dos soluciones m√°s importantes, que son:</p>
<ul>
<li>
<p><strong>Vol√∫menes Docker:</strong> Si elegimos resolver el problema anterior usando <strong>vol√∫menes docker</strong> quiere decir que vamos a guardar nuestros datos en una parte del sistema la cual es gestionada por Docker y a la que debido a sus permisos, s√≥lo Docker tendr√° acceso. Se guardan en <code>/var/lib/docker/volumes</code>. Esta soluci√≥n se suele usar en los siguientes casos:</p>
<ul>
<li>
<p>Para compartir datos entre contenedores, ya que simplemente deber√°n usar el mismo vol√∫men.</p>
</li>
<li>
<p>Para copias de seguridad.</p>
</li>
<li>
<p>Cuando queremos almacenar los datos de nuestros contenedores en un servidor cloud.</p>
</li>
</ul>
</li>
<li>
<p><strong>Bind Mount:</strong> Al usar esta soluci√≥n, lo que estamos haciendo es <em>mapear</em> (o montar) una parte de mi sistema de ficheros (de la que normalmente tenemos el control) con una parte del sistema de ficheros del contenedor. De esta forma conseguimos:</p>
<ul>
<li>
<p>Compartir ficheros entre el <em>anfitri√≥n</em> y el <em>contenedor</em></p>
</li>
<li>
<p>Que otras aplicaciones que no sean docker tengan acceso a esos ficheros, ya sean c√≥digo, ficheros, etc&hellip;</p>
</li>
</ul>
</li>
</ul>
<h2 id="gestionando-vol√∫menes">Gestionando vol√∫menes</h2>
<p>Algunos de los comandos m√°s √∫tiles para trabajas con vol√∫menes docker son:</p>
<ul>
<li>
<p><strong><code>docker volume create</code>:</strong> Crea un volumen con el nombre indicado.</p>
</li>
<li>
<p><strong><code>docker volume rm</code>:</strong> Elimina el volumen indicado.</p>
</li>
<li>
<p><strong><code>docker volume prune</code>:</strong> Elimina los vol√∫menes que no est√°n siendo usados por ning√∫n contenedor</p>
</li>
<li>
<p><strong><code>docker volume ls</code>:</strong> Lista los vol√∫menes y proporciona algo de informaci√≥n adicional.</p>
</li>
<li>
<p><strong><code>docker volume inspect</code>:</strong> Tambi√©n lista los vol√∫menes pero de forma mucho m√°s detallada que <code>volume ls</code>.</p>
</li>
</ul>
<h2 id="asociando-almacenamiento-a-los-contenedores">Asociando almacenamiento a los contenedores</h2>
<p>Para usar tanto los <strong>vol√∫emenes docker</strong> como los <strong>bind mount</strong> necesitaremos usar dos <em>flags</em> (u opciones) para usar cualquiera de los dos m√©todos de almacenamiento:</p>
<ul>
<li>
<p><code>--volume</code> o <code>-v</code></p>
</li>
<li>
<p><code>--mount</code></p>
</li>
</ul>
<p>Es importante que tengamos en cuenta dos cosas importantes para realizar estas dos operaciones:</p>
<ul>
<li>
<p>Si existe el directorio donde vamos a montar tanto los <strong>vol√∫menes docker</strong> como los <strong>bind mount</strong>, este se sobreescribir√°, por lo que toda la informaci√≥n de dicho directorio (repito, si existe) se eliminar√°.</p>
</li>
<li>
<p>Si nuestra carpeta donde hemos indicado el montaje no existe y hacemos un <strong>bind mount</strong> esta carpeta se crear√° y tendremos un directorio vac√≠o como almacenamiento.</p>
</li>
<li>
<p>Si usamos im√°genes de DockerHub, debemos prestar atenci√≥n ala informaci√≥n de su p√°gina, ya que ah√≠ nos dice c√≥mo persistir los datos de dicha imagen.</p>
</li>
</ul>
<h2 id="ejemplo-usando-vol√∫menes-docker">Ejemplo usando Vol√∫menes Docker</h2>
<pre><code>docker volume create prueba
prueba

docker run --name docker_nginx --mount type=volume,src=prueba,dst=/usr/share/nginx/html/ -p 8080:80 -d nginx
c0b5f88eb32bcb96b0285b345d41e77d01f42a768ec09484cf4d1f2f0b79a3d0

docker exec docker_nginx bash -c 'echo &quot;&lt;h1&gt;Esto es una prueba de almacenamiento&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html'

curl 127.0.0.1:8080
&lt;h1&gt;Esto es una prueba de almacenamiento&lt;/h1&gt;

docker rm -f docker_nginx
docker_nginx

docker run --name docker_nginx2 -v prueba:/usr/share/nginx/html/ -p 8080:80 -d nginx
bfff1f83504544106dd916db40ca4e566e508ca9bb95b387d7efe9422660176d

curl 127.0.0.1:8080
&lt;h1&gt;Esto es una prueba de almacenamiento&lt;/h1&gt;
</code></pre><p>Como podemos ver arriba, hemos creado un volumen llamado <code>prueba</code>, despu√©s hemos creado un contenedor y hemos montado el volumen que hemos creado en la ruta <code>/usr/share/nginx/html/</code>, la cual es la que usa <code>nginx</code> por defecto para servir su p√°gina de ejemplo, hemos usado el comando <code>exec</code> de docker y hemos sustituido el fichero <code>inde.html</code> predeterminado por uno modificado por m√≠, para despu√©s eliminar el contenedor y crear uno nuevo con el volumen <code>prueba</code> ya montado y como podemos ver, la informaci√≥n del fichero <code>index.html</code> modificado la seguimos teniendo.</p>
<p>Si ubiesemos usado la opci√≥n <code>--mount</code> de esta forma <code>--mount type=volume,dst=/usr/share/nginx/html/</code> se hubiese creado un nuevo volumen, ya que no hemos indicado ninguno que pueda usar.</p>
<p>Si usamos la opci√≥n <code>-v</code> e indicamos un nombre, se crear√° un nuevo volumen docker</p>
<pre><code>docker run --name docker_nginx2 -v prueba2:/usr/share/nginx/html/ -p 8080:80 -d nginx
bab32cc75f4f2fea0fa51c4b4244cc942ea90e0220c7a5f105276b4be3c7ebd8

docker volume ls
DRIVER              VOLUME NAME
local               prueba
local               prueba2
</code></pre><h2 id="ejemplo-usando-bind-mount">Ejemplo usando bind mount</h2>
<p>En este caso vamos a crear un dicrectorio en el sistema de archivos del anfitri√≥n y dentro de dicho directorio vamos a crear un archivo <code>index.html</code></p>
<pre><code>mkdir prueba

echo &quot;&lt;h1&gt;Esto es una prueba de bind mount&lt;/h1&gt;&quot; &gt; prueba/index.html

docker run --name docker_nginx -v /home/juanan/prueba:/usr/share/nginx/html/ -p 8080:80 -d nginx
98115c4a68a25f3b3ecedf3c81dbae1de5f3017ac84edf1c3ecc47636de0c993

curl 127.0.0.1:8080
&lt;h1&gt;Esto es una prueba de bind mount&lt;/h1&gt;

docker rm -f docker_nginx
docker_nginx

docker run --name docker_nginx2 --mount type=bind,src=https://juanan219.github.io/home/juanan/prueba,dst=/usr/share/nginx/html/ -p 8080:80 -d nginx
b231eaf659b738d74e4e119165666db0de61cee862af7d9c8b56f4b9e62dacdb

curl 127.0.0.1:8080
&lt;h1&gt;Esto es una prueba de bind mount&lt;/h1&gt;
</code></pre><p>En este ejemplo hemos hecho lo mismo que con los vol√∫menes, pero con la diferencia que en lugar de crear un vol√∫men hemos usado un <strong>bind mount</strong>, es decir, hemos creado un directorio que tiene en su interior un archivo <code>index.html</code>.</p>
<p>Como podemos comprobar, tambi√©n podemos modificar el ficheor aunque el contenedor est√© activo</p>
<pre><code>echo &quot;&lt;h1&gt;Este archivo se ha modificado&lt;/h1&gt;&quot; &gt; prueba/index.html

curl 127.0.0.1:8080
&lt;h1&gt;Este archivo se ha modificado&lt;/h1&gt;
</code></pre><h2 id="ejercicio-contenedor-mariadb-con-almacenamiento-persistente">Ejercicio: Contenedor mariadb con almacenamiento persistente</h2>
<p>En la <a href="https://hub.docker.com/_/mariadb">documentaci√≥n de mariadb</a> en DockerHub nos dice que podemos crear un contenedor co almacenamiento persistente de la siguiente manera</p>
<pre><code>docker run --name some-mariadb -v /home/usuario/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mariadb
</code></pre><p>Esto quiere decir que se va a crear un directorio en <code>/home/usuario/datadir</code>, en el cual se va a guardar la informaci√≥n de la base de datos. Si tenemos que crear un nuevo contenedor, indicaremos ese directorio como <strong>bind mount</strong> y volveremos a tener accesible dicha informaci√≥n.</p>
<pre><code>docker run --name docker_mariadb -v /home/juanan/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mariadb
1f6d378308ff18e795969319bc48e4ae170f45ce3f6c5b6b60b4b7b3ee474a4c

ls datadir/
aria_log.00000001  aria_log_control  ib_buffer_pool  ibdata1  ib_logfile0  ibtmp1  multi-master.info  mysql  performance_schema

docker rm -f docker_mariadb
docker_mariadb

docker run --name docker_mariadb --mount type=bind,src=https://juanan219.github.io/home/juanan/datadir,dst=/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mariadb
12d8638feb79eac951036bcc80e3bf98885ca491b84d561d4f57d16f6056e0f9

docker exec -it docker_mariadb bash -c 'mysql -u root -p$MYSQL_ROOT_PASSWORD'
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.5.8-MariaDB-1:10.5.8+maria~focal mariadb.org binary distribution

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.000 sec)
</code></pre><h2 id="qu√©-informaci√≥n-tenemos-que-guardar">¬øQu√© informaci√≥n tenemos que guardar?</h2>
<p>Para terminar: ¬øQu√© debemos guardar de forma persistente en un contenedor?</p>
<ul>
<li>
<p>Datos de una aplicaci√≥n</p>
</li>
<li>
<p>Logs del servicio</p>
</li>
<li>
<p>Configuraci√≥n del servicio: En este caso podemos a√±adir la configuraci√≥n a la imagen, pero ser√° necesaria la creaci√≥n de una nueva imagen si cambiamos la configuraci√≥n. Si la guardamos en un volumen hay que tener en cuenta de tener ese fichero en el entrono de producci√≥n (puede ser bueno, porque las configuraciones de los distintos entornos pueden variar).</p>
</li>
</ul>
<h1 id="ejercicios">Ejercicios</h1>
<ol>
<li>
<p><strong>Vamos a trabajar con vol√∫menes docker:</strong></p>
<ul>
<li><strong>Crea un volumen que se llame <code>miweb</code></strong></li>
</ul>
</li>
</ol>
<pre><code>docker volume create miweb
miweb
</code></pre><pre><code>* **Crea un contenedor desde la imagen `php:7.4-apache` donde montes en el directorio `/var/www/html` (que sabemos que es el `documentroot` del servidor que nos ofrece esa imagen) el volumen docker que has creado**
</code></pre>
<pre><code>docker run --name apache_php --mount type=volume,src=miweb,dst=/var/www/html -p 8080:80 -d php:7.4-apache
2cd22b7170868556cfb8f3bc3dc599186bb5880bf903455f0175a9203f7c22dc
</code></pre><pre><code>* **Utiliza el comando `docker cp` para copiar un fichero `info.php` en el directorio `/var/www/html`**
</code></pre>
<pre><code>echo &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt; info.php
docker cp info.php apache_php:/var/www/html
</code></pre><pre><code>* **Accede al contenedor desde el navegador para ver la informaci√≥n ofrecida por el fichero `php.info`**
</code></pre>
<p><img src="/Docker/Documentacion/8.png" alt="Captura 8"></p>
<pre><code>* **Borra el contenedor**
</code></pre>
<pre><code>docker rm -f apache_php
apache_php
</code></pre><pre><code>* **Crea un nuevo contenedor y monta el mismo volumen como en el ejercicio anterior**
</code></pre>
<pre><code>docker run --name apache_php --mount type=volume,src=miweb,dst=/var/www/html -p 8080:80 -d php:7.4-apache
6a6735f1bfb70eecbeb60769dbf20dd4539211d60832294f1961101a52b53564
</code></pre><pre><code>* **Accede al contenedor desde el navegador para ver la informaci√≥n ofrecida por el fichero `info.php`. ¬øSegu√≠a existiendo ese fichero?**
</code></pre>
<p><img src="/Docker/Documentacion/8.png" alt="Captura 8"></p>
<p>S√≠, sigue existiendo el fichero, ya que est√° almacenado en el volumen.</p>
<ol start="2">
<li>
<p><strong>Vamos a trabajar con <code>bind mount</code></strong></p>
<ul>
<li><strong>Crea un directorio en tu host y dentro crea el fichero <code>index.html</code></strong></li>
</ul>
</li>
</ol>
<pre><code>mkdir miweb

echo &quot;&lt;h1&gt;Esto es una prueba de Bind Mount&lt;/h1&gt;&quot; &gt; miweb/index.html
</code></pre><pre><code>* **Crea un contenedor desde la imagen `php:7.4-apache` donde montes en el directorio `/var/www/html` el directorio que has creado por medio de `bind mount`**
</code></pre>
<pre><code>docker run --name apache_php -v /home/juanan/miweb:/var/www/html -p 8080:80 -d php:7.4-apache
93b868e418f4713d450f8fec76848a57ab7bcff7887bf3f294fa04d029a66192
</code></pre><pre><code>* **Accede al contenedor desde el navegador para ver la informaci√≥n ofrecida por el fichero `index.html`**
</code></pre>
<p><img src="/Docker/Documentacion/9.png" alt="Captura 9"></p>
<pre><code>* **Modifica el fichero `index.html` en tu host y comprueba que al refrescar la p√°gina ofrecida por el contenedor, el contenido ha cambiado**
</code></pre>
<pre><code>echo &quot;&lt;h1&gt;Esto es la segunda prueba de Bind Mount&lt;/h1&gt;&quot; &gt; miweb/index.html
</code></pre><p><img src="/Docker/Documentacion/10.png" alt="Captura 10"></p>
<pre><code>* **Borra el contenedor**
</code></pre>
<pre><code>docker rm -f apache_php
apache_php
</code></pre><pre><code>* **Crea un nuevo contenedor y monta el mismo directorio como en el ejercicio anterior**
</code></pre>
<pre><code>docker run --name apache_php -v /home/juanan/miweb:/var/www/html -p 8080:80 -d php:7.4-apache
122bcc07c2a88f0d685c5d09eaa02e144c57408a0e8dee8e2079d778381e0314
</code></pre><pre><code>* **Accede al contenedor desde el navegador para ver la informaci√≥n ofrecida por el fichero `index.html`. ¬øSe sigue viendo el mismo contenido?**
</code></pre>
<p><img src="/Docker/Documentacion/10.png" alt="Captura 10"></p>
<p>S√≠, se sigue visualizando el mismo contenido, ya que el fichero <code>index.html</code> est√° almacenado en el directorio que usamos como <strong>bind mount</strong>.</p>
<ol start="3">
<li>
<p><strong>Contenedores con almacenamiento persistente</strong></p>
<ul>
<li><strong>Crea un contenedor de la imagen <code>nextcloud</code> (usando <code>sqlite</code>) configurando un almacenamiento como nos muestra la <a href="https://hub.docker.com/_/nextcloud">documentaci√≥n de la imagen</a> en DockerHub (pero utilizando <code>bind mount</code>). Sube alg√∫n fichero.</strong></li>
</ul>
</li>
</ol>
<pre><code>docker run --name docker_nextcloud -v /home/juanan/nextcloud:/var/www/html -p 8080:80 -d nextcloud
ffe4a54d5410245278ebe2e23ce9afec5c6dcece6f8ae3f52660337ff9ab0047

echo &quot;Esto es un fichero de prueba&quot; &gt; prueba.txt
</code></pre><p><img src="/Docker/Documentacion/11.png" alt="Captura 11"></p>
<p>He subido el archivo llamado <code>prueba.txt</code></p>
<pre><code>* **Elimina el contenedor**
</code></pre>
<pre><code>docker rm -f docker_nextcloud
docker_nextcloud
</code></pre><pre><code>* **Crea un contenedor nuevo con la misma configuraci√≥n de vol√∫menes. Comprueba que la informaci√≥n que ten√≠amos (ficheros, usuarios, etc...) sigue existiendo**
</code></pre>
<pre><code>docker run --name docker_nextcloud -v /home/juanan/nextcloud:/var/www/html -p 8080:80 -d nextcloud
967f37669b512c53d4bf5b235bd53a8970c04b748517a1a27358617cb633911d

ls nextcloud/
3rdparty  AUTHORS  console.php  core      custom_apps  index.html  lib  ocm-provider  ocs-provider  remote.php  robots.txt  themes
apps      config   COPYING      cron.php  data         index.php   occ  ocs           public.php    resources   status.php  version.php
</code></pre><pre><code>* **Comprueba el contenido del directorio que se ha creado en el host**
</code></pre>
<p><img src="/Docker/Documentacion/12.png" alt="Captura 12"></p>
<p>Como podemos comprobar, despu√©s de haber eliminado el contenedor y habiendo hecho uno nuevo, como los archivos de <code>nextcloud</code> se encontraban en el directorio <code>/home/juanan/nextcloud</code>, siguen estando ah√≠, por lo que ni los usuarios, ni los datos que hemos subido se han eliminado.</p>
]]></content>
        </item>
        
        <item>
            <title>Creando escenarios multicontenedor con docker-compose</title>
            <link>https://juanan219.github.io/posts/2021/02/creando-escenarios-multicontenedor-con-docker-compose/</link>
            <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/creando-escenarios-multicontenedor-con-docker-compose/</guid>
            <description>En ocasiones, es necesario disponer de m√∫ltiples contenedores, como por ejemplo:
  Cuando necesitamos varios servicios para que la aplicaci√≥n funcione, como por ejemplo con Wordpress, necesitar√≠amos un contenedor para la propia aplicaci√≥n web y otro contenedor para el servidor de bases de datos MySQL.
  Si tenemos nuestra aplicaci√≥n construida con microservicios, de los cuales, cada microservicio se ejecutar√° en un contenedor independiente.
  Cuando trabajamos en escenarios en los que necesitamos varios contenedores, podemos usar docker-compose para gestionarlos.</description>
            <content type="html"><![CDATA[<p>En ocasiones, es necesario disponer de m√∫ltiples contenedores, como por ejemplo:</p>
<ul>
<li>
<p>Cuando necesitamos varios servicios para que la aplicaci√≥n funcione, como por ejemplo con <code>Wordpress</code>, necesitar√≠amos un contenedor para la propia aplicaci√≥n web y otro contenedor para el servidor de bases de datos <code>MySQL</code>.</p>
</li>
<li>
<p>Si tenemos nuestra aplicaci√≥n construida con microservicios, de los cuales, cada microservicio se ejecutar√° en un contenedor independiente.</p>
</li>
</ul>
<p>Cuando trabajamos en escenarios en los que necesitamos varios contenedores, podemos usar <code>docker-compose</code> para gestionarlos.</p>
<p>Vamos a definir el escenario con un fchero llamado <code>docker-compose.yml</code> y vamos a gestionar el tiempo de vida de las aplicaciones y de todos los componentes que necesitamos con la utilidad <code>docker-compose</code>.</p>
<h2 id="ventajas-de-usar-doker-compose">Ventajas de usar doker-compose</h2>
<ul>
<li>
<p>Hacer todo de manera declarativa para no tener que repetir el proceso una vez que se construye el escenario.</p>
</li>
<li>
<p>Poner en marcha todos los contenedores que necesita mi aplicaci√≥n de una sola vez y correctamente configurados.</p>
</li>
<li>
<p>Garantizar que los contenedores se arrancan en el orden adecuado. Por ejemplo: Si mi aplicaci√≥n no puede funcionar debidamente hasta que el servidor de bases de datos est√© en marcha, configurar√© el fichero para que se arranque antes el contenedor de la base de datos que el de la aplicaci√≥n que depende de ella.</p>
</li>
<li>
<p>Asegurarnos de que hay comunicaci√≥n entre los contenedores que pertenecen a la aplicaci√≥n.</p>
</li>
</ul>
<h2 id="instalaci√≥n-de-docker-compose">Instalaci√≥n de docker-compose</h2>
<ul>
<li>Para instalarlo desde repositorios de debian</li>
</ul>
<pre><code>sudo apt-get install docker-compose
</code></pre><ul>
<li>Para instalarlo con <code>pip</code> desde un entorno virtual:</li>
</ul>
<pre><code>python3 -m venv docker-compose
source docker-compose/bin/activate
(docker-compose) ~# pip install docker-compose
</code></pre><h2 id="el-fichero-docker-composeyml">El fichero docker-compose.yml</h2>
<p>Con el fichero <code>docker-compose.yml</code> definimos el escenario. El programa <code>docker-compose</code> se tiene que ejecutar en el directorio en el cual est√© este fichero. Por ejemplo, para la ejecuci√≥n de un <code>wordpress</code> persistente deber√≠amos tener un fichero con el siguiente contenido:</p>
<pre><code>version: '3.1'

services:

	wordpress:
		container_name: docker_wp
		image: wordpress
		restart: always
		environment:
			WORDPRESS_DB_HOST: maria_wp
			WORDPRESS_DB_USER: wordpress_user
			WORDPRESS_DB_PASSWORD: wordpress_passwd
			WORDPRESS_DB_NAME: wp_db
		volumes:
			- /home/juanan/wordpress/wp:/var/www/html

	db:
		container_name: maria_wp
		image: mariadb
		restart: always
		environment:
			MYSQL_DATABASE: wp_db
			MYSQL_USER: wordpress_user
			MYSQL_PASSWORD: wordpress_passwd
			MYSQL_ROOT_PASSWORD: root
		volumes:
			- /home/juanan/wordpress/mariadb:/var/lib/mysql
</code></pre><p>Puedes encontrar todos los par√°metros que se pueden definir en la <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">documentaci√≥n oficial</a>.</p>
<p>Algunos par√°metros interesantes:</p>
<ul>
<li>
<p><strong><code>restart: always</code>:</strong> Indicamos la pol√≠tica de reinicio del contenedor, ya que si por alg√∫n motivo falla, esta se reinicia en lugar de quedarse apagada.</p>
</li>
<li>
<p><strong><code>depend: on</code>:</strong> Indica la dependencia entre contenedores. No va a iniciar un contenedor hasta que otro est√© funcionando.</p>
</li>
</ul>
<p>Cuando creamos un escenario con el comando <code>docker-compose</code> se crea una nueva red definida por el usuario <code>docker</code>, en la cual se conectan los contenedores, por lo que tenemos resoluci√≥n de nombres por DNS que resuelve tanto por el nombre (por ejemplo <code>servidor_mysql</code>) como por el alias (por ejemplo <code>maria_wp</code>).</p>
<ul>
<li>Para crear un escenario</li>
</ul>
<pre><code>docker compose up -d
</code></pre><ul>
<li>Para listar los contenedores</li>
</ul>
<pre><code>docker-compose ps
</code></pre><ul>
<li>Para parar los contenedores</li>
</ul>
<pre><code>docker-compose stop
</code></pre><ul>
<li>Para borrar los contenedores</li>
</ul>
<pre><code>docker-compose rm
</code></pre><h2 id="el-comando-docker-compose">El comando docker-compose</h2>
<p>Una vez que hemos creado el archivo <code>docker-compose.yml</code> tenemos que empezar a crear los contenedores que se describen en su contenido. Esto lo haremos ejecutando el comando <code>docker-compose</code> en el directorio en el que se encuentra el fichero de configuraci√≥n.</p>
<p>Los subcomandos m√°s usados son:</p>
<ul>
<li>
<p><strong><code>docker-compose up</code>:</strong> Crea los contenedores (servicios) que est√°n definidos en el <code>docker-compose.yml</code></p>
</li>
<li>
<p><strong><code>docker-compose up -d</code>:</strong> Crea en modo <code>detach</code> los contenedores (servicios) que est√°n descritos en el <code>docker-compose.yml</code></p>
</li>
<li>
<p><strong><code>docker-compose stop</code>:</strong> Detiene los contenedores que se han lanzado con <code>docker-compose up</code></p>
</li>
<li>
<p><strong><code>docker-compose run</code>:</strong> Inicia los contenedores definidos en el <code>docker-compose.yml</code> que est√©n preparados</p>
</li>
<li>
<p><strong><code>docker-compose rm</code>:</strong> Borra los contenedores preparados del escenario. Con la opci√≥n <code>-f</code> borra tambi√©n los que se est√©n ejecutando</p>
</li>
<li>
<p><strong><code>docker-compose pause</code>:</strong> Pausa los contenedores que se han lanzado con <code>docker-compose up</code></p>
</li>
<li>
<p><strong><code>docker-compose unpause</code>:</strong> Reaunda los contenedores que est√°n pausados</p>
</li>
<li>
<p><strong><code>docker-compose restart</code>:</strong> Reinicia los contenedores. Este comando es ideal para reiniciar servicios con nuevas configuraciones.</p>
</li>
<li>
<p><strong><code>docker-compose down</code>:</strong> Para los contenedores, los borra y con ellos borra las redes que se han creado con <code>docker-compose up</code> (en el caso de haberse creado)</p>
</li>
<li>
<p><strong><code>docker-compose down -v</code>:</strong> Para los contenedores, los elimina, elimina sus redes y sus vol√∫menes.</p>
</li>
<li>
<p><strong><code>docker-compose logs servicio1</code>:</strong> Muestra los logs del servicio llamado <code>servicio1</code> que estaba descrito en el <code>docker-compose.yml</code></p>
</li>
<li>
<p><strong><code>docker-compose exec servicio1 /bin/bash</code>:</strong> Ejecuta una orden, en este caso, <code>/bin/bash</code> en el contenedor llamado <code>servicio1</code> que estaba descrito en el <code>docker-compose.yml</code></p>
</li>
<li>
<p><strong><code>docker-compose build</code>:</strong> Ejecuta, si est√° indicado, el proceso de construcci√≥n de una imagen que va a ser usada en el <code>docker-compose.yml</code> a partir de los ficheros <code>dockerfile</code> que se indican.</p>
</li>
<li>
<p><strong><code>docker-compose top</code>:</strong> Muestra los procesos que est√°n ejecut√°ndose en cada uno de los contenedores de los servicios.</p>
</li>
</ul>
<h1 id="ejercicios">Ejercicios</h1>
<ol>
<li><strong>Instala <code>docker-compose</code> en tu ordenador. Copia el fichero <code>docker-compose.yml</code> de la <a href="https://hub.docker.com/_/wordpress">documentaci√≥n</a> de la imagen oficial de <code>wordpress</code></strong></li>
</ol>
<pre><code>sudo apt-get install docker-compose

sudo mkdir docker-compose

cd docker-compose/

nano docker-compose.yml

version: '3.1'

services:

  wordpress:
    image: wordpress
    restart: always
    ports:
      - 8080:80
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: exampleuser
      WORDPRESS_DB_PASSWORD: examplepass
      WORDPRESS_DB_NAME: exampledb
    volumes:
      - wordpress:/var/www/html

  db:
    image: mysql:5.7
    restart: always
    environment:
      MYSQL_DATABASE: exampledb
      MYSQL_USER: exampleuser
      MYSQL_PASSWORD: examplepass
      MYSQL_RANDOM_ROOT_PASSWORD: '1'
    volumes:
      - db:/var/lib/mysql

volumes:
  wordpress:
  db:
</code></pre><ol start="2">
<li><strong>Modifica el <code>docker-compose.yml</code> para que use el puerto <code>8001</code></strong></li>
</ol>
<pre><code>services:
	wordpress:
[...]
		ports:
			- 8080:8001
[...]
</code></pre><ol start="3">
<li><strong>Modifica el <code>docker-compose.yml</code> para que la base de datos se llame <code>db_wordpress</code></strong></li>
</ol>
<pre><code>services:
	wordpress:
[...]
		environment:
[...]
			WORDPRESS_DB_NAME: db_wordpress
[...]
		db:
[...]
			environment:
				MYSQL_DATABASE: db_wordpress
[...]
</code></pre><ol start="4">
<li><strong>Modifica el <code>docker-compose.yml</code> para usar <code>bind mount</code> en lugar de vol√∫menes</strong></li>
</ol>
<pre><code>services:
	wordpress:
[...]
		volumes:
			- /home/juanan/wordpress/wp:/var/www/html
[...]
	db:
[...]
		volumes:
			- /home/juanan/wordpress/mariadb:/var/lib/mysql
</code></pre><ol start="5">
<li><strong>Levanta el escenario con <code>docker-compose</code></strong></li>
</ol>
<pre><code>docker-compose up -d
</code></pre><ol start="6">
<li><strong>Muestra los contenedores con <code>docker-compose</code></strong></li>
</ol>
<pre><code>docker-compose ps
       Name                     Command               State               Ports             
--------------------------------------------------------------------------------------------
juanan_db_1          docker-entrypoint.sh mysqld      Up      3306/tcp, 33060/tcp           
juanan_wordpress_1   docker-entrypoint.sh apach ...   Up      80/tcp, 0.0.0.0:8080-&gt;8001/tcp
</code></pre><ol start="7">
<li><strong>Accede a la aplicaci√≥n y comprueba que funciona</strong></li>
</ol>
<p><img src="/Docker/Documentacion/18.png" alt="Captura 17"></p>
<ol start="8">
<li><strong>Comprueba el almacenamiento que has definido y que se ha creado una red de tipo <code>bridge</code></strong></li>
</ol>
<pre><code>docker network ls
[...]
NETWORK ID          NAME                DRIVER              SCOPE
64f74f4b8685        juanan_default      bridge              local
[...]
</code></pre><ol start="9">
<li><strong>Borra el escenario con <code>docker-compose</code></strong></li>
</ol>
<pre><code>docker-compose down
Stopping juanan_wordpress_1 ... done
Stopping juanan_db_1        ... done
Removing juanan_wordpress_1 ... done
Removing juanan_db_1        ... done
Removing network juanan_default
</code></pre>]]></content>
        </item>
        
        <item>
            <title>Uso de las Imagenes Docker</title>
            <link>https://juanan219.github.io/posts/2021/02/uso-de-las-imagenes-docker/</link>
            <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/uso-de-las-imagenes-docker/</guid>
            <description>Registros de Im√°genes: DockerHub Las im√°genes de Docker son plantillas de solo lectura, es decir, una imagen que contiene archivos de un sistema operativo como Debian, solo nos permitir√° crear contenedores basados en dicha imagen, pero los cambios que hagamos en el contenedor, una vez que se ha detenido, no se ver√°n reflejados en la imagen.
El nombre de una im√°gen suele estar formado por tres partes:
usuario/nombre:etiqueta   usuario: El nombre del usuario que ha generado la imagen.</description>
            <content type="html"><![CDATA[<h2 id="registros-de-im√°genes-dockerhub">Registros de Im√°genes: DockerHub</h2>
<p><img src="/Docker/Documentacion/3.png" alt="Captura 3"></p>
<p>Las im√°genes de Docker son plantillas de solo lectura, es decir, una imagen que contiene archivos de un sistema operativo como Debian, solo nos permitir√° crear contenedores basados en dicha imagen, pero los cambios que hagamos en el contenedor, una vez que se ha detenido, no se ver√°n reflejados en la imagen.</p>
<p>El nombre de una im√°gen suele estar formado por tres partes:</p>
<pre><code>usuario/nombre:etiqueta
</code></pre><ul>
<li>
<p><strong><code>usuario</code>:</strong> El nombre del usuario que ha generado la imagen. Si la subimos a DockerHub, este nombre debe de ser el mismo con el que nos hemos dado de alta en la plataforma. Las <strong>im√°genes oficiales</strong> en DockerHub no tienen nombre de usuario, sino que se llaman igual que la imagen. Por ejemplo, la imagen de debian se llamar√≠a <code>debian/debian</code></p>
</li>
<li>
<p><strong><code>nombre</code>:</strong> Nombre significativo de la imagen.</p>
</li>
<li>
<p><strong><code>etiqueta</code>:</strong> Nos permite versionar las im√°genes. De esta manera podemos controlar los cambios que vamos haciendo en ellas. Si al descargar una imagen no le ponemos etiqueta, por defecto se descargar√° la versi√≥n <code>latest</code>, por lo que la mayor√≠a de las im√°genes tienen una versi√≥n con ese nombre.</p>
</li>
</ul>
<h2 id="gesti√≥n-de-im√°genes">Gesti√≥n de im√°genes</h2>
<p>Para crear un contenedor, es necesario crearlo con una imagen que tengamos descargada en nuestro registro local. Por lo tanto al ejecutar <code>docker run</code> se comprueba si tenemos la versi√≥n indicada de la imagen, si no es as√≠, se procede a descargarla.</p>
<p>Las principales instrucciones para trabajar con im√°genes son:</p>
<ul>
<li>
<p><strong><code>docker images</code>:</strong> Muestra las im√°genes que tenemos en nuestro registro local.</p>
</li>
<li>
<p><strong><code>docker pull</code>:</strong> Nos permite descargar la √∫ltima versi√≥n de la imagen indicada.</p>
</li>
<li>
<p><strong><code>docker rmi</code>:</strong> Nos permite eliminar im√°genes (No podemos eliminar una imagen si tenemos un contenedor us√°ndola).</p>
</li>
<li>
<p><strong><code>docker search</code>:</strong> Busca im√°genes en DockerHub.</p>
</li>
<li>
<p><strong><code>docker inspect</code>:</strong> No da informaci√≥n sobre la imagen indicada:</p>
<ul>
<li>
<p><code>ID</code> y <code>checksum</code> de la imagen.</p>
</li>
<li>
<p>Los puertos abiertos</p>
</li>
<li>
<p>La arquitectura y el sistema operativo de la imagen</p>
</li>
<li>
<p>El tama√±o de la imagen</p>
</li>
<li>
<p>Los vol√∫menes</p>
</li>
<li>
<p>El ENTRYPOINT (es lo que ejecuta el comando <code>docker run</code>)</p>
</li>
<li>
<p>Las capas</p>
</li>
<li>
<p>Etc&hellip;</p>
</li>
</ul>
</li>
</ul>
<h2 id="c√≥mo-se-organizan-las-im√°genes">¬øC√≥mo se organizan las im√°genes?</h2>
<p>Las im√°genes est√°n hechas de <strong>capas ordenadas</strong>. Las capas son un conjunto de cambios en el sistema de archivos. Cuando tomas todas las capas y las apilas obtienes una nueva imagen que tiene todos los cambios acumulados.</p>
<p>Si tienes varias im√°genes que tienen capas en com√∫n, estas capas se almacenar√°n s√≥lo una vez.</p>
<p><img src="/Docker/Documentacion/4.png" alt="Captura 4"></p>
<p>Cuando se crea un nuevo contenedor, todas las capas de la imagen son de s√≥lo lectura, pero se le agrega encima una peque√±a capa de lectura-escritura, con lo cual, todos los cambios realizados en dicho contenedor son almacenados en esa capa que se le ha a√±adido.</p>
<p>El propio contenedor no puede modificar la im√°gen (ya que es de s√≥lo lectura), por lo que crear√° una copia del fichero en su capa superior y desde ah√≠ en adelante, cualquiera que trate de acceder al archivo, obtendr√° la capa superior.</p>
<p><img src="/Docker/Documentacion/5.png" alt="Captura 5"></p>
<p>Cuando creamos un contenedor, √©ste ocupa muy poco espacio en el disco, esto se debe a que las capas de la imagen desde la que se ha creado dicho contenedor, se comparten entre otros contenedores.</p>
<p>Este es el tama√±o de la imagen <code>debian</code> que hemos usado en la documentaci√≥n anterior:</p>
<pre><code>juanan@juananpc:~$ docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
[...]
debian                        latest              5890f8ba95f6        2 weeks ago         114MB
[...]
</code></pre><p>Vamos a crear un contenedor interactivo y despu√©s visualizamos los contenedores con la opci√≥n <code>-s</code> (size o tama√±o en espa√±ol) para ver cu√°nto ocupan</p>
<pre><code>juanan@juananpc:~$ docker run -it --name contenedor_debian debian /bin/bash
root@3f284a03c3d9:/# exit

juanan@juananpc:~$ docker ps -a -s
CONTAINER ID      IMAGE            COMMAND           CREATED           STATUS                     PORTS        NAMES               SIZE
3f284a03c3d9      debian           &quot;/bin/bash&quot;       8 seconds ago     Exited (0) 5 seconds ago                contenedor_debian   0B (virtual 114MB)
</code></pre><p>Podemos ver que el tama√±o del contenedor es de <code>0B</code> y el tama√±o virtual es de <code>114MB</code>, que es el tama√±o de la imagen <code>debian</code>, pero si volvemos a arrancar el contenedor, nos conectamos y creamos un fichero, podemos ver que el tama√±o cambia</p>
<pre><code>juanan@juananpc:~$ docker start contenedor_debian
contenedor_debian

juanan@juananpc:~$ docker attach contenedor_debian
root@3f284a03c3d9:/# echo 'Hola, esto es un fichero de prueba' &gt; fichero.txt
root@3f284a03c3d9:/# exit

juanan@juananpc:~$ docker ps -a -s
CONTAINER ID      IMAGE             COMMAND           CREATED           STATUS                     PORTS          NAMES               SIZE
3f284a03c3d9      debian            &quot;/bin/bash&quot;       4 minutes ago     Exited (0) 6 seconds ago                  contenedor_debian   91B (virtual 114MB)
</code></pre><p>Por √∫ltimo, si solicitamos informaci√≥n sobre una imagen podemos ver informaci√≥n sobre las capas:</p>
<pre><code>docker inspect debian
[...]
&quot;RootFS&quot;: {
            &quot;Type&quot;: &quot;layers&quot;,
            &quot;Layers&quot;: [
                &quot;sha256:7f03bfe4d6dc12155877f0d2e8b3429090bad1af7b005f75b7b3a874f386fd5a&quot;
            ]
        },
[...]
</code></pre><h2 id="creaci√≥n-de-instancias-desde-im√°genes">Creaci√≥n de instancias desde im√°genes</h2>
<p>Hay dos tipos de im√°genes en los repositorios y se dividen seg√∫n la utilidad que nos ofrecen:</p>
<ul>
<li>
<p>Im√°genes para ejecutar contenedores de diferentes sistemas operativos (Ubuntu, CentOS, Debian, etc&hellip;)</p>
</li>
<li>
<p>Im√°genes para ejecutar servicios asociados (Apache, MySQL, Tomcat, etc&hellip;)</p>
</li>
</ul>
<p>Todas las im√°genes tienen un proceso que se ejecuta por defecto, pero nosotros, al crear un contenedor, podemos indicarle el proceso que queremos que realice al crear dicho contenedor.</p>
<p>Por ejemplo, en la imagen <code>ubuntu</code>, el proceso por defecto es <code>bash</code>, por lo que podemos ejecutar:</p>
<pre><code>docker run -it --name contenedor_ubuntu ubuntu
</code></pre><p>Pero podemos indicar el comando que queremos ejecutar en la creaci√≥n del contenedor</p>
<pre><code>docker run -it --name contenedor_ubuntu ubuntu /bin/echo 'Hola mundo'
</code></pre><p>Otro ejemplo: la imagen <code>httpd:2.4</code> ejecuta un servidor web por defecto, por lo tanto podemos crear el contenedor de la siguiente forma:</p>
<pre><code>docker run -d --name contenedor_apache -p 8080:80 httpd:2.4
</code></pre><h1 id="ejercicios">Ejercicios</h1>
<ol>
<li><strong>Descarga las siguientes im√°genes: <code>ubuntu:18.04</code>, <code>httpd</code>, <code>tomcat:9.0.39-jdk11</code>, <code>jenkins/jenkins:lts</code>, <code>php:7.4-apache</code></strong></li>
</ol>
<ul>
<li><code>ubuntu:18.04</code>:</li>
</ul>
<pre><code>docker pull ubuntu:18.04
</code></pre><ul>
<li><code>httpd</code>:</li>
</ul>
<pre><code>docker pull httpd
</code></pre><ul>
<li><code>tomcat:9.0.39-jdk11</code>:</li>
</ul>
<pre><code>docker pull tomcat:9.0.39-jdk11
</code></pre><ul>
<li><code>jenkins/jenkins:lts</code></li>
</ul>
<pre><code>docker pull jenkins/jenkins
</code></pre><ul>
<li><code>php:7.4-apache</code>:</li>
</ul>
<pre><code>docker pull php:7.4-apache
</code></pre><ol start="2">
<li><strong>Muestra las im√°genes que tienes descargadas</strong></li>
</ol>
<pre><code>docker images
</code></pre><ol start="3">
<li><strong>Crea un contenedor demonio con la imagen <code>php:7.4-apache</code></strong></li>
</ol>
<pre><code>docker run --name php_apache -p 8080:80 -d php:7.4-apache
371dba835efa5e4739efbf9d2bdc59f66c79d636dbc20f80e9388b83724adb7e

docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
371dba835efa        php:7.4-apache      &quot;docker-php-entrypoi‚Ä¶&quot;   8 seconds ago       Up 7 seconds        0.0.0.0:8080-&gt;80/tcp   php_apache
</code></pre><ol start="4">
<li><strong>Comprueba el tama√±o del contenedor en el disco duro</strong></li>
</ol>
<pre><code>docker ps -s
CONTAINER ID     IMAGE             COMMAND                  CREATED              STATUS              PORTS                  NAMES          SIZE
371dba835efa     php:7.4-apache    &quot;docker-php-entrypoi‚Ä¶&quot;   About a minute ago   Up About a minute   0.0.0.0:8080-&gt;80/tcp   php_apache     2B (virtual 414MB)
</code></pre><p>El tama√±o del contenedor es de <code>2B</code></p>
<ol start="5">
<li><strong>Con la opci√≥n <code>docker cp</code> podemos copiar ficheros desde o hacia un contenedor. Copia el fichero <code>info.php</code> al directorio <code>/var/www/html</code> del contenedor</strong></li>
</ol>
<pre><code>echo '&lt;?php phpinfo(); ?&gt;' &gt; info.php

docker cp info.php php_apache:/var/www/html
</code></pre><p>Ahora el contenedor ocupa <code>22B</code></p>
<ol start="6">
<li><strong>Vuelve a comprobar el espacio del contenedor</strong></li>
</ol>
<pre><code>docker ps -s
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES          SIZE
371dba835efa        php:7.4-apache      &quot;docker-php-entrypoi‚Ä¶&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:8080-&gt;80/tcp   php_apache     22B (virtual 414MB)
</code></pre><ol start="7">
<li><strong>Accede al fichero <code>info.php</code> desde un navegador</strong></li>
</ol>
<p><img src="/Docker/Documentacion/6.png" alt="Captura 6"></p>
]]></content>
        </item>
        
        <item>
            <title>Redes en Docker</title>
            <link>https://juanan219.github.io/posts/2021/02/redes-en-docker/</link>
            <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/redes-en-docker/</guid>
            <description>Introducci√≥n a las redes en Docker Cada vez que creamos un contenedor en Docker, √©ste se conecta a una red virtual y docker hace una configuraci√≥n del sistema (usando interfaces puente e iptables para que la m√°quina tenga una ip interna, tenga acceso al exterior, podamos mapear puertos (DNAT), etc&amp;hellip;)
Podemos ver el comando ip si ejecutamos un contenedor con este comando.
docker run -it --rm --name docker_debian debian bash -c &#39;ip a&#39; 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.</description>
            <content type="html"><![CDATA[<h2 id="introducci√≥n-a-las-redes-en-docker">Introducci√≥n a las redes en Docker</h2>
<p>Cada vez que creamos un contenedor en Docker, √©ste se conecta a una red virtual y docker hace una configuraci√≥n del sistema (usando interfaces puente e iptables para que la m√°quina tenga una ip interna, tenga acceso al exterior, podamos mapear puertos (DNAT), etc&hellip;)</p>
<p>Podemos ver el comando ip si ejecutamos un contenedor con este comando.</p>
<pre><code>docker run -it --rm --name docker_debian debian bash -c 'ip a'
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
56: eth0@if57: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre><blockquote>
<p><strong>Nota:</strong> Si usamos la opci√≥n <code>--rm</code> el contenedor se elimina nada m√°s que termina de hacer el proceso que se le ha encargado.</p>
</blockquote>
<p>Como podemos ver arriba, a nuestro contenedor se le ha asignado la ip <code>172.17.0.2/16</code> y se ha creado una interfaz tipo <code>bridge</code> en la m√°quina anfitriona, a la cual se conectan los contenedores.</p>
<pre><code>ip a
[...]
6: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:65üíøe3:5c brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:65ff:fecd:e35c/64 scope link 
       valid_lft forever preferred_lft forever
[...]
</code></pre><p>Adem√°s de que se han generado ciertas reglas en el cortafuegos para gestionar las conexiones de los contenedores. Podemos ejecutar <code>iptables -nL</code> e <code>iptables -t nat -nL</code> para comprobar estas reglas.</p>
<h2 id="tipos-de-redes-en-docker">Tipos de redes en Docker</h2>
<p>Cuando instalamos docker tenemos las siguientes redes predefinidas:</p>
<pre><code>docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
09540af8449f        bridge              bridge              local
2e4b519fab3b        host                host                local
0ac9f5f0f96b        none                null                local
</code></pre><ul>
<li>Si creamos cualquier contenedor, por defecto se va a conectar a la red llamada <code>bridge</code>, cuyo direccionamiento predeterminado es 172.17.0.0/16. Los contenedores conectados a esta red que quieren exponer alg√∫n puerto al exterior tienen que usar el par√°metro <code>-p</code> para mapear puertos.</li>
</ul>
<p>Este tipo de red nos permite:</p>
<pre><code>* Aislar los contenedores que tengo en distintas subredes docker, de tal manera de que los contenedores de esa subred puedan acceder exclusivamente a contenedores de su misma subred.

* Aislar los contenedores del acceso exterior.

* Publicar servicios que tengamos en los contenedores mediante redirecciones que docker implementar√° con las reglas iptables necesarias.
</code></pre>
<p><img src="/Docker/Documentacion/13.png" alt="Captura 13"></p>
<ul>
<li>Si conectamos un contenedor a la red <strong>host</strong>, el contenedor estar√≠a en la misma red que nuestra m√°quina anfitriona, por lo que coger√° direccionamiento IP de nuestro DHCP, adem√°s de que los puertos son accesibles directamente desde el host. Si queremos conectar un contenedor que vamos a crear a una red en concreto, deberemos hacer:</li>
</ul>
<pre><code>docker run --name docker_nginx --network host -d nginx
720ea83dafd587b86799717b5a9fe072245526aa85ca60ec910b7656decc769d

docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
b1f6a0f81813        nginx               &quot;/docker-entrypoint.‚Ä¶&quot;   7 seconds ago       Up 6 seconds                            docker_nginx
</code></pre><p>Ahora podremos acceder a la p√°gina de <code>nginx</code> directamente desde el puerto 80</p>
<p><img src="/Docker/Documentacion/14.png" alt="Captura 14"></p>
<ul>
<li>La red <strong>none</strong> no configurar√° ninguna IP para el contenedor y no tiene acceso a ning√∫n tipo de red ni equipos. Tiene una direcci√≥n <code>loopback</code> y se suele usar para ejecutar trabajos por lotes.</li>
</ul>
<h2 id="gestionando-las-redes-en-docker">Gestionando las redes en Docker</h2>
<p>Tenemos que hacer una diferenciaci√≥n entre dos tipos de redes <strong>bridged</strong>:</p>
<ul>
<li>
<p>La red creada por defecto por Docker para que funcionen todos los contenedores.</p>
</li>
<li>
<p>Y las redes <code>bridged</code> definidas por el usuario.</p>
</li>
</ul>
<p>Las redes <code>bridged</code> que usan por defecto los contenedores se diferencian en varios aspectos de las redes <code>bridged</code> creadas por nosotros. Estos aspectos son los siguientes:</p>
<ul>
<li>
<p>Las redes que definimos proporcionan <strong>resoluci√≥n DNS</strong> entre los contenedores, cosa que no hace la red por defecto a no ser que usemos opciones que ya se consideran <code>deprecated</code> (como la opci√≥n <code>--link</code>).</p>
</li>
<li>
<p>Puedo conectar en caliente los contenedores a redes <code>bridged</code> definidas por nosotros, mientras que si uso la red por defecto, tengo que parar previamente el contenedor.</p>
</li>
<li>
<p>Me permite gestionar de manera m√°s segura el aislamiento de los contenedores, ya que si no indico una red, al crear el contenedor, √©ste se conecta a la red por defecto, en la cual puede haber otros contenedores con servicios que no tienen nada que ver con √©l.</p>
</li>
<li>
<p>Tengo m√°s control sobre las redes si las defino yo, ya que los contenedores de una red por defecto comparten todos la misma configuraci√≥n de red (MTU, reglas iptables, etc&hellip;)</p>
</li>
<li>
<p>Los contenedores de la red por defecto comparten ciertas variables de entorno, por lo que pueden generar algunos conflictos.</p>
</li>
</ul>
<p>Por todo esto, es muy importante que los contenedores que tenemos en producci√≥n se est√©n ejecutando en redes definidas por nosotros.</p>
<p>Para gestionar las redes definidas por el usuario:</p>
<ul>
<li>
<p><strong><code>docker network ls</code>:</strong> Lista las redes.</p>
</li>
<li>
<p><strong><code>docker network create</code>:</strong> Crea redes, por ejemplo</p>
</li>
</ul>
<pre><code>docker network create red1

docker netwprk create -d bridge --subnet 172.24.0.0/16 --gateway 172.24.0.1 red2
</code></pre><ul>
<li>
<p><strong><code>docker network prune</code>:</strong> Elimina las redes que no se est√°n usando</p>
</li>
<li>
<p><strong><code>docker network rm</code>:</strong> Elimina la red o redes que le indiquemos, teniendo en cuenta siempre que no podemos eliminar una red mientras se est√° usando, por lo que deberemos eliminar o desconectar de dicha red el contenedor que la est√° usando.</p>
</li>
<li>
<p><strong><code>docker network inspect</code>:</strong> Nos da informaci√≥n sobre la red</p>
</li>
</ul>
<p>Cada red que creamos crea un puente de red espec√≠fico para que podamos ver cada red definida con el comando <code>ip a</code> desde la m√°quina anfitriona.</p>
<p><img src="/Docker/Documentacion/15.png" alt="Captura 15"></p>
<h2 id="asociaci√≥n-de-redes-a-los-contenedores">Asociaci√≥n de redes a los contenedores</h2>
<p>Tenemos dos redes creadas por el usuario</p>
<pre><code>docker network create --subnet 172.28.0.0/16 --gateway 172.28.0.1 red1
8ea35d168034d65ea8acc8b51af61467db3ef172efd1cb7130617903c27b61b1

docker network create red2
692f9cc348f7486e26f63f49f8184f94743160ebd88da65bed057f0508e5ce97

docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
[...]
8ea35d168034        red1                bridge              local
692f9cc348f7        red2                bridge              local
</code></pre><p>Vamos a crear dos contenedores conectados a la <code>red1</code>, el primer contenedor va a tener ls imagen <code>nginx</code> y el segundo va a tener la imagen <code>debian</code>, desde la cual vamos a realizar un dig hacia el servidor web nginx</p>
<pre><code>docker run --name docker_nginx --network red1 -d nginx
4decc4259730743ca45883fe2540bddc9289211fe37dd011143b8899094ce7b1

docker run -it --name docker_debian --network red1 debian bash

root@d701cdcce43d:/# apt-get update

root@d701cdcce43d:/# apt-get install dnsutils

root@d701cdcce43d:/# dig docker_nginx

; &lt;&lt;&gt;&gt; DiG 9.11.5-P4-5.1+deb10u3-Debian &lt;&lt;&gt;&gt; docker_nginx
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64571
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;docker_nginx.      IN  A

;; ANSWER SECTION:
docker_nginx.   600 IN  A 172.28.0.2

;; Query time: 0 msec
;; SERVER: 127.0.0.11#53(127.0.0.11)
;; WHEN: Tue Feb 23 13:10:26 UTC 2021
;; MSG SIZE  rcvd: 58
</code></pre><ul>
<li>
<p><strong><code>docker network connect</code>:</strong> Conectar contenedor a una red</p>
</li>
<li>
<p><strong><code>docker network disconnect</code>:</strong> Desconectar contenedor de una red</p>
</li>
</ul>
<p>Vamos a conectar el contenedor que est√° ejecutando la imagen de <code>nginx</code> a la <code>red2</code></p>
<pre><code>docker network connect red2 docker_nginx
</code></pre><p>Ahora lo vamos a desconectar</p>
<pre><code>docker network disconnect red2 docker_nginx
</code></pre><p>Tanto al crear un contenedor con la opci√≥n <code>--network</code> como al usar el comando <code>docker network connect</code> podemos usar diferentes opciones:</p>
<ul>
<li>
<p><strong><code>--dns</code>:</strong> Para establecer servidores DNS predeterminados</p>
</li>
<li>
<p><strong><code>--ip6</code>:</strong> Para establecer la direcci√≥n IPv6</p>
</li>
<li>
<p><strong><code>--hostname</code> o <code>-h</code>:</strong> Para establecer el nombre de host del contenedor. Si no establecemos el <code>hostname</code> con esta opci√≥n, √©ste ser√° el nombre del propio contenedor.</p>
</li>
</ul>
<h2 id="ejercicio-instalaci√≥n-de-wordpress">Ejercicio: Instalaci√≥n de Wordpress</h2>
<p>Para la instalaci√≥n de Workdpress necesitaremos dos contenedores:</p>
<ul>
<li>
<p>La base de datos (imagen <code>mariadb</code>)</p>
</li>
<li>
<p>El servidor web con la aplicaci√≥n (imagen <code>workpress</code>)</p>
</li>
</ul>
<p>Los dos contenedores tienen que estar en la misma red y deben de tener acceso por nombres (resoluci√≥n DNS) ya que de principio, no sabemos que IP tiene cada contenedor. Por lo tanto vamos a crear los contenedores en la misma red:</p>
<pre><code>docker network create --subnet 172.10.0.0/16 --gateway 172.10.0.1 red_wp
2aa05c8085811dced11f38777f286d1e37f1a47654120a86f82026fd316847bf

mkdir -p wordpress/mariadb wordpress/wp

docker run --name maria_wp --network red_wp -v /home/juanan/wordpress/mariadb:/var/lib/mysql -e MYSQL_DATABASE=wp_db -e MYSQL_USER=usuario_wp -e MYSQL_PASSWORD=passwd_wp -e MYSQL_ROOT_PASSWORD=root -d mariadb
346f6aeb93f65f97e26e592922dc7d947d597da5f32d36caae74edb16b44240e

docker run --name docker_wp --network red_wp -v /home/juanan/wordpress/wp:/var/www/html/wp-content -e WORDPRESS_DB_HOST=maria_wp -e WORDPRESS_DB_USER=usuario_wp -e WORDPRESS_DB_PASSWORD=passwd_wp -e WORDPRESS_DB_NAME=wp_db -p 80:80 -d wordpress
aad713617b33eac4d316080fd0319516faea84d2719677ffee1a335426e17571

docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
aad713617b33        wordpress           &quot;docker-entrypoint.s‚Ä¶&quot;   19 seconds ago      Up 17 seconds       0.0.0.0:80-&gt;80/tcp   docker_wp
346f6aeb93f6        mariadb             &quot;docker-entrypoint.s‚Ä¶&quot;   4 minutes ago       Up 4 minutes        3306/tcp             maria_wp
</code></pre><p><img src="/Docker/Documentacion/16.png" alt="Captura 16"></p>
<h1 id="ejercicios">Ejercicios</h1>
<ol>
<li><strong>Ejecuta una instrucci√≥n docker para visualizar el contenido del fichero <code>wp-config.php</code> y verifica que los par√°metros de conexi√≥n a la base de datos son los mismos que los que indicamos en las variables de entorno</strong></li>
</ol>
<pre><code>docker exec docker_wp bash -c 'cat /var/www/html/wp-config.php'
[...]
define( 'DB_NAME', 'wp_db');

/** MySQL database username */
define( 'DB_USER', 'usuario_wp');

/** MySQL database password */
define( 'DB_PASSWORD', 'passwd_wp');

/** MySQL hostname */
define( 'DB_HOST', 'maria_wp');
[...]
</code></pre><ol start="2">
<li><strong>Ejecuta una instrucci√≥n docker para comprobar que desde el servidor <code>docker_wp</code> podemos hacer un ping usando el nombre <code>maria_wp</code> (Tendr√°s que instalar el paquete <code>iputils-ping</code> en dicho contenedor)</strong></li>
</ol>
<ul>
<li>Actualizamos la lista de paquetes e instalamos el paquete <code>iputils-ping</code></li>
</ul>
<pre><code>docker exec docker_wp bash -c 'apt-get update &amp;&amp; apt-get install -y iputils-ping &amp;&amp; ping maria_wp'
[...]
PING maria_wp (172.10.0.2) 56(84) bytes of data.
64 bytes from maria_wp.red_wp (172.10.0.2): icmp_seq=1 ttl=64 time=0.156 ms
64 bytes from maria_wp.red_wp (172.10.0.2): icmp_seq=2 ttl=64 time=0.118 ms
64 bytes from maria_wp.red_wp (172.10.0.2): icmp_seq=3 ttl=64 time=0.122 ms
</code></pre><ol start="3">
<li><strong>Visualiza el fichero <code>/etc/mysql/mariadb.conf.d/50-server.cnf</code> del contenedor de la base de datos y comprueba c√≥mo est√° configurado el par√°metro <code>bind-address</code></strong></li>
</ol>
<pre><code>docker exec maria_wp bash -c 'cat /etc/mysql/mariadb.conf.d/50-server.cnf | grep &quot;bind-address&quot;'
#bind-address            = 127.0.0.1
</code></pre><p>El par√°metro <code>bind-address</code> est√° comentado</p>
<ol start="4">
<li><strong>Instala otro CMS PHP siguiendo la documentaci√≥n de DockerHub de la aplicaci√≥n seleccionada</strong></li>
</ol>
<pre><code>docker network create red_joomla
b19cc1d0fedb6a59b52b7dab3c99390b4cb9c1aa3a84bb84374dc18826d1bd56

docker run --name my_joomla --network red_joomla -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=joomla_db -e MYSQL_USER=joomla_user -e MYSQL_PASSWORD=joomla_passwd -d mariadb
938ec4c9b3beb8b4229b9d54e1bc327e6d6c09f1530ff451935750890d0c2d2a

docker run --name docker_joomla --network red_joomla -e JOOMLA_DB_HOST=my_joomla -e JOOMLA_DB_USER=joomla_user -e JOOMLA_DB_PASSWORD=joomla_passwd -e JOOMLA_DB_NAME=joomla_db -p 80:80 -d joomla
3815c6e2843428eb2a62d595365e8f868afcd3cfe0415b38f911d95132041768
</code></pre><p><img src="/Docker/Documentacion/17.png" alt="Captura 17"></p>
]]></content>
        </item>
        
        <item>
            <title>Introduccion a Docker</title>
            <link>https://juanan219.github.io/posts/2021/02/introduccion-a-docker/</link>
            <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/introduccion-a-docker/</guid>
            <description>Introducci√≥n a Docker El objetivo de Docker es el despliegue de aplicaciones en capsuladas en contenedores, en lugar de desplegar las aplicaciones en m√°quinas virtuales.
Docker est√° formado por varios componentes:
  Docker Engine: Es un demonio de cualquier distribuci√≥n Linux, el cual tiene una API para gestionar las im√°genes y contenedores. Sirve para crear im√°genes, subirlas y bajarlas de un registro docker, ejecutar y gestionar contenedores.
  Docker Client: Este es el CLI (Command Line Interface) que nos permite controlar Docker Engine.</description>
            <content type="html"><![CDATA[<h2 id="introducci√≥n-a-docker">Introducci√≥n a Docker</h2>
<p>El objetivo de <strong>Docker</strong> es el despliegue de aplicaciones en capsuladas en contenedores, en lugar de desplegar las aplicaciones en m√°quinas virtuales.</p>
<p><strong>Docker</strong> est√° formado por varios componentes:</p>
<ul>
<li>
<p><strong>Docker Engine:</strong> Es un demonio de cualquier distribuci√≥n Linux, el cual tiene una API para gestionar las im√°genes y contenedores. Sirve para crear im√°genes, subirlas y bajarlas de un registro docker, ejecutar y gestionar contenedores.</p>
</li>
<li>
<p><strong>Docker Client:</strong> Este es el CLI (Command Line Interface) que nos permite controlar <code>Docker Engine</code>. Este cliente se puede configurar tanto local como remoto permiti√©ndonos gestionar nuestro entorno de desarrollo local como nuestro entorno de producci√≥n remoto.</p>
</li>
<li>
<p><strong>Docker Registry:</strong> Almacena las im√°genes gestionadas por <code>Docker Engine</code>. Este apartado de docker es totalmente fundamental, ya que es el que se encarga de distribuir nuestras aplicaciones. Se puede instalar en cualquier servidor y de manera totalmente independiente, pero el proyecto docker nos ofrece <strong>Docker Hub</strong>.</p>
</li>
</ul>
<h2 id="instalaci√≥n-de-docker">Instalaci√≥n de Docker</h2>
<ul>
<li>Instalaci√≥n de la comunidad</li>
</ul>
<pre><code>sudo apt-get install docker.io
</code></pre><ul>
<li>Si queremos usar docker con el usuario sin privilegios</li>
</ul>
<pre><code>sudo usermod -aG docker usuario
</code></pre><h2 id="el-hola-mundo-de-docker">El &ldquo;Hola Mundo&rdquo; de Docker</h2>
<p>Comprobaremos que todo esto funciona ejecutando nuestro primer contenedor llamado <code>hello-world</code>.</p>
<pre><code>docker run hello-world
</code></pre><ul>
<li>
<p>¬øQu√© es lo que ocurre cuando ejecutamos <code>docker run hello-world</code>?</p>
<ul>
<li>
<p>Al ser la primera vez que ejecuto un contenedor basado en la imagen <code>hello-world</code>, esta se descarga desde el repositorio que se encuentra en el registro que vamos a usar, en nuestro caso es <code>DockerHub</code>.</p>
</li>
<li>
<p>Despu√©s de descargarse muestra el mensaje de bienvenida, consecuencia de crear y arrancar un contenedor basado en la imagen <code>hello-world</code>.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Otro ejemplo:</strong></p>
<pre><code>docker run ubuntu /bin/echo 'Hello world'
</code></pre><p>Con el comando <code>run</code> vamos a ejecutar un contenedor en el que vamos a ejecutar un comando, en este caso, hemos creado un contenedor con una imagen basada en <code>ubuntu</code>. Como es la primera vez que ejecutamos un contenedor basado en esta imagen, se descargar√° de <code>DockerHub</code>, si no es as√≠, esta no se descargar√° y simplemente se ejecutar√° el contenedor.</p>
<p>Despu√©s podemos comprobar que se ha ejecutado con el comando <code>ps -a</code>, de esta forma podemos ver todos los contenedores que hemos ejecutado</p>
<pre><code>docker ps -a
</code></pre><h2 id="comandos-de-docker">Comandos de Docker</h2>
<ul>
<li>Listar los contenedores que se est√°n ejecutando</li>
</ul>
<pre><code>docker ps
</code></pre><ul>
<li>Listar todos los contenedores</li>
</ul>
<pre><code>docker ps -a
</code></pre><ul>
<li>Eliminar un contenedor identificando su <code>ID</code></li>
</ul>
<pre><code>docker rm [ID]
</code></pre><ul>
<li>Eliminar un contenedor por su nombre</li>
</ul>
<pre><code>docker rm [nombre]
</code></pre><ul>
<li>Ver todas las im√°genes que tenemos descargadas:</li>
</ul>
<pre><code>docker images
</code></pre><ul>
<li>Iniciar un contenedor</li>
</ul>
<pre><code>docker start [nombre]
</code></pre><ul>
<li>Conectarse a un contenedor</li>
</ul>
<pre><code>docker attach [nombre]
</code></pre><ul>
<li>Ver lo que est√° haciendo un contenedor</li>
</ul>
<pre><code>docker logs [nombre]
</code></pre><ul>
<li>Parar un contenedor</li>
</ul>
<pre><code>docker stop [nombre]
</code></pre><ul>
<li>Eliminar un contenedor</li>
</ul>
<pre><code>docker rm [nombre]
</code></pre><h2 id="ejecutando-un-contenedor-interactivo">Ejecutando un contenedor interactivo</h2>
<p>Para abrir una sesi√≥n interactiva deberemos ejecutar el par√°metro <code>-i</code> y con la opci√≥n <code>-t</code> nos permite usar un pseudo-terminal que nos permite interactuar con el contenedor ejecutado. Tambi√©n le podemos indicar un nombre con la opci√≥n <code>--name</code> y despu√©s acompa√±amos a este comando con el nombre de la im√°gen que vamos a usar, en este caso <code>ubuntu</code> y por √∫ltimo, ponemos el comando que vamos a ejecutar, el cual ser√° <code>/bin/bash</code>, el cual lanzar√° una <code>bash</code> desde el contenedor.</p>
<pre><code>docker run -it --name contenedor1 ubuntu /bin/bash
</code></pre><ul>
<li>
<p>Resumen del comando:</p>
<ul>
<li><strong>-i:</strong> Abrir una sesi√≥n de forma interactiva</li>
<li><strong>-t:</strong> Usar una terminal</li>
<li><strong>&ndash;name [nombre]:</strong> Definimos el nombre que queremos que tenga el contenedor que vamos a ejecutar</li>
<li><strong>ubuntu:</strong> Es el nombre de la imagen que vamos a usar en este contenedor</li>
<li><strong>/bin/bash:</strong> Es el comando que va a ejecutar el contenedor cuando √©ste se ejecute.</li>
</ul>
</li>
</ul>
<p>Los conetedores son ef√≠meros, es decir, nada m√°s que el contenedor termine su trabajo, √©ste se para. Si queremos volver a usar un contenedor que ya hemos ejecutado con anterioridad usaremos el comando <code>start</code> y si nos queremos conectar a √©l usamos la opci√≥n <code>attach</code></p>
<pre><code>docker start contenedor1
docker attach contenedor1
</code></pre><p>Si el contenedor ya se est√° ejecutando, podemos ejecutar comandos en √©l con el comando <code>exec</code></p>
<pre><code>docker exec contenedor1 ls -l
</code></pre><p>Si lo que queremos es reiniciar el contenedor, solo deberemos usar el comando <code>restart</code></p>
<pre><code>docker restart contenedor1
</code></pre><p>Para ver informaci√≥n del contenedor</p>
<pre><code>docker inspect contenedor1
</code></pre><p>En realidad, todas las <code>im√°genes docker</code> tienen definidas un proceso que se ejecuta. En la imagen <code>ubuntu</code>, por ejemplo, el proceso por defecto que se ejecuta es <code>bash</code>, por lo que podr√≠amos haber ejecutado</p>
<pre><code>docker run -it --name contenedor1 ubuntu
</code></pre><p>Esto quiere decir que no era necesario acompa√±ar a dicho comando con el comando del final <code>/bin/bash</code>, ya que la imagen lo ejecuta por defecto.</p>
<h2 id="creando-un-contenedor-demonio">Creando un contenedor demonio</h2>
<p>Podemos crear un contenedor demonio con la opci√≥n <code>-d</code> del comando <code>run</code>, para que el contenedor se quede corriendo en segundo plano.</p>
<pre><code>docker run -d --name contenedor2 ubuntu /bin/sh -c &quot;yes hello world&quot;
</code></pre><p>Vamos a comprobar que se est√° ejecutando</p>
<pre><code>docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
32d7577b9a6c        ubuntu              &quot;/bin/sh -c 'yes hel‚Ä¶&quot;   26 seconds ago      Up 25 seconds                           contenedor2
</code></pre><p>Podemos comprobar qu√© es lo que est√° haciendo dicho contenedor con el comando</p>
<pre><code>docker logs contenedor2
</code></pre><p>Para parar un contenedor y eliminarlo</p>
<pre><code>docker stop contenedor2
docker rm contenedor2
</code></pre><p>Comprobamos que se ha eliminado</p>
<pre><code>docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre><p>Como no se puede eliminar un contenedor que est√° en ejecuci√≥n , podemos forzar su eliminaci√≥n con el comando</p>
<pre><code>docker rm -f contenedor2
</code></pre><h2 id="creando-un-contenedor-con-un-servidor-web">Creando un contenedor con un servidor web</h2>
<p>Tenemos muchas im√°genes en el repositorio p√∫blico de <strong>DockerHub</strong>. Si queremos crear un contenedor con un servidor <code>apache 2.4</code></p>
<pre><code>docker run -d --name my-apache-app -p 8080:80 httpd:2.4
</code></pre><ul>
<li><strong>-p 8080:80:</strong> Con esta opci√≥n mapeamos un puerto del equipo donde tenemos instalado <code>docker</code> con un puerto del contenedor. Para comprobar que esto funciona, podemos entrar desde nuestro navegador a la <code>IP del contenedor</code> y al <code>puerto 8080</code></li>
</ul>
<p>Podemos ver lo que est√° haciendo <code>apache</code> mirando los logs con el comando que hemos visto antes, pero si le a√±adimos la opci√≥n <code>-f</code> podremos ver los logs e3n tiempo real</p>
<pre><code>docker logs -f my-apache-app
</code></pre><h2 id="configuraci√≥n-de-contenedores-con-variables-de-entorno">Configuraci√≥n de contenedores con variables de entorno</h2>
<p>Ahora veremos que al crear un contenedor, dependiendo de lo que queramos hacer, requiere una configuraci√≥n espec√≠fica, as√≠ que crearemos variables de entorno para poder configurarlo. Para crear las variables de entorno usaremos la opci√≥n <code>-e</code> o <code>--env</code></p>
<pre><code>docker run -it --name prueba -e USUARIO=prueba ubuntu bash
root@18edc1b5414e:/# echo $USUARIO
prueba
</code></pre><p>En algunas ocasiones, es necesario inicializar alguna variable de entorno para que el contenedor pueda ser ejecutado. Si miramos la <a href="https://hub.docker.com/_/mariadb">documentaci√≥n</a> en DockerHub de la imagen de <code>mariadb</code>, vemos que podemos definir algunas variables de entorno como pueden ser: <code>MYSQL_DATABASE</code>, <code>MYSQL_USER</code>, <code>MYSQL_PASSWORD</code>, etc&hellip; pero una de ellas hay que indicarlas de manera obligatoria para poder ejecutar dicho contenedor y esa variable es la contrase√±a del usuario <code>root</code> (<code>MYSQL_ROOT_PASSWORD</code>), por lo tanto, el comando de ejecuci√≥n del contenedor con la imagen de <code>mariadb</code> es</p>
<pre><code>docker run --name contenedor_mariadb -e MYSQL_ROOT_PASSWORD=root -d mariadb
</code></pre><p>Podemos verificar que est√° funcionando</p>
<pre><code>docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
0922f9029852        mariadb             &quot;docker-entrypoint.s‚Ä¶&quot;   6 seconds ago       Up 4 seconds        3306/tcp            contenedor_mariadb
</code></pre><p>Entre todas las veriables de entorno que tiene definidas por defecto la imagen de <code>mariadb</code>, podemos encontrar la variable <code>MYSQL_ROOT_PASSWORD</code> con el valor <code>root</code> que le hemos definido. Para ver todas las variables de entorno de un contenedor podemos ejecutar el siguiente comando</p>
<pre><code>docker exec -it contenedor_mariadb env
[...]
MYSQL_ROOT_PASSWORD=root
[...]
</code></pre><p>Y si queremos acceder a dicha m√°quina para comprobar que podemos acceder a la base de datos con esa contrase√±a, podemos ejecutar</p>
<pre><code>root@0922f9029852:/# mysql -u root -p$MYSQL_ROOT_PASSWORD
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 4
Server version: 10.5.8-MariaDB-1:10.5.8+maria~focal mariadb.org binary distribution

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt;
</code></pre><h1 id="ejercicios">Ejercicios</h1>
<ol>
<li><strong>Instala un docker en una m√°quina y config√∫ralo para que se pueda acceder sin privilegios</strong></li>
</ol>
<ul>
<li>Instalaci√≥n</li>
</ul>
<pre><code>sudo apt-get install docker.io
</code></pre><ul>
<li>Configuraci√≥n para acceder sin privilegios</li>
</ul>
<pre><code>sudo usermod -aG docker juanan
</code></pre><ol start="2">
<li><strong>Crea un contenedor interactivo desde una imagen debian. Instala un paquete (por ejemplo <code>nano</code>). Sal de la terminal, ¬øsigue el contenedor corriendo?¬øPor qu√©? Vuelve a iniciar el contenedor y accede de nuevo a √©l de forma interactiva. ¬øSigue instalado el <code>nano</code>? Sal del contenedor y b√≥rralo. Crea un nuevo contenedor interactivo desde la misma imagen. ¬øTiene el <code>nano</code> instalado?</strong></li>
</ol>
<ul>
<li>Creo un contenedor interactivo con la imagen <code>debian</code></li>
</ul>
<pre><code>docker run -it --name contenedor_debian debian /bin/bash
</code></pre><ul>
<li>Instalo <code>nano</code> en el contenedor</li>
</ul>
<pre><code>root@e0e5f5265ae7:/# apt-get update
root@e0e5f5265ae7:/# apt-get install nano
</code></pre><ul>
<li>Salgo de la terminal y compruebo si el contenedor sigue corriendo</li>
</ul>
<pre><code>root@e0e5f5265ae7:/# exit
exit
juanan@juananpc:~$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre><pre><code>* El `contenedor` no sigue corriendo porque los `contenedores docker` son ef√≠meros y cuando terminan su funci√≥n principal, estos se paran y se quedan guardados, pero parados. Podemos ver los contenedores que est√°n creados, pero parados con el comando `ps -a`
</code></pre>
<pre><code>juanan@juananpc:~$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES
e0e5f5265ae7        debian              &quot;/bin/bash&quot;         3 minutes ago       Exited (0) About a minute ago                       contenedor_debian
</code></pre><ul>
<li>Vuelvo a iniciar el contenedor y accedo a √©l de forma interactiva</li>
</ul>
<pre><code>juanan@juananpc:~$ docker start contenedor_debian
contenedor_debian
juanan@juananpc:~$ docker attach contenedor_debian
root@e0e5f5265ae7:/# whereis nano
nano: /bin/nano /usr/share/nano /usr/share/man/man1/nano.1.gz /usr/share/info/nano.info.gz
</code></pre><pre><code>* Al volver a iniciar el contenedor s√≠ que sigue teniendo instalado `nano`
</code></pre>
<ul>
<li>Salgo del contenedor, lo borro, vuelvo a crear un nuevo contenedor con la misma imagen y compruebo si tiene <code>nano</code> instalado</li>
</ul>
<pre><code>root@e0e5f5265ae7:/# exit
exit
juanan@juananpc:~$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
juanan@juananpc:~$ docker rm contenedor_debian
contenedor_debian
juanan@juananpc:~$ docker run -it --name contenedor_debian2 debian /bin/bash
root@cc6520b717b2:/# whereis nano
nano:
</code></pre><pre><code>* No tiene `nano` instalado, ya que hemos eliminado el contenedor entero y √©ste no ten√≠a ning√∫n dispositivo de almacenamiento.
</code></pre>
<ol start="3">
<li><strong>Crea un contenedor demonio con un servidor <code>nginx</code>. Al crear el contenedor, ¬øhas tenido que indicar alg√∫n comando para que lo ejecute? Accede al navegador web y comprueba que el servidor est√° funcionando. Muestra los logs del contenedor.</strong></li>
</ol>
<ul>
<li>Creo un contenedor demonio con una imagen de nginx</li>
</ul>
<pre><code>docker run -p 8080:80 --name docker_nginx -d nginx
</code></pre><pre><code>* No, no he tenido que ejecutar ning√∫n comando para que el contenedor ejecute el servicio de `nginx` al ser creado.
</code></pre>
<ul>
<li>
<p>Accedo a mi navegador web y compruebo que est√° ejecutando el servicio de <code>nginx</code>. A esta p√°gina web podemos acceder de tres formas:</p>
<ul>
<li>A trav√©s de la ip del contenedor, para ello deberemos averiguarla con el siguiente comando</li>
</ul>
</li>
</ul>
<pre><code>docker inspect docker_nginx
[...]
&quot;IPAddress&quot;: &quot;172.17.0.2&quot;,
[...]
</code></pre><pre><code>* A trav√©s de nuestra ip de la tarjeta de red y poniendo al final `:8080`

* A trav√©s de nuestra ip de `loopback` y el puerto `:8080` (`127.0.0.1:8080`)
</code></pre>
<p><img src="/Docker/Documentacion/1.png" alt="Captura 1"></p>
<ul>
<li>Muestro los logs del contenedor</li>
</ul>
<pre><code>juanan@juananpc:~$ docker logs docker_nginx
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
172.17.0.1 - - [22/Feb/2021:20:29:17 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot; &quot;-&quot;
172.17.0.1 - - [22/Feb/2021:20:29:17 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 555 &quot;http://192.168.1.112:8080/&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot; &quot;-&quot;
2021/02/22 20:29:17 [error] 30#30: *2 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.1.112:8080&quot;, referrer: &quot;http://192.168.1.112:8080/&quot;
172.17.0.1 - - [22/Feb/2021:20:29:22 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot; &quot;-&quot;
2021/02/22 20:29:22 [error] 30#30: *4 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;127.0.0.1:8080&quot;, referrer: &quot;http://127.0.0.1:8080/&quot;
172.17.0.1 - - [22/Feb/2021:20:29:22 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 555 &quot;http://127.0.0.1:8080/&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot; &quot;-&quot;
</code></pre><ol start="4">
<li><strong>Crea un contenedor con la aplicaci√≥n <code>Nextcloud</code>, mirando la documentaci√≥n de DockerHub, para personalizar el nombre de la base de datos sqlite que va a utilizar</strong></li>
</ol>
<ul>
<li>Creo un contenedor con la imagen de <code>Nextcloud</code> con la variable de entorno <code>SQLITE_DATABASE</code> cuyo nombre va a ser <code>juanan_db</code></li>
</ul>
<pre><code>docker run -p 8080:80 --name docker_nextcloud -e SQLITE_DATABASE=juanan_db -d nextcloud
</code></pre><ul>
<li>Comprobamos que funciona
<img src="/Docker/Documentacion/2.png" alt="Captura 2"></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Configuraci√≥n de VPN con clave secreta</title>
            <link>https://juanan219.github.io/posts/2021/02/configuraci%C3%B3n-de-vpn-con-clave-secreta/</link>
            <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/configuraci%C3%B3n-de-vpn-con-clave-secreta/</guid>
            <description>Configuraci√≥n de openVPN de acceso remoto con clave est√°tica compartida Vamos a levantar un escenario en OpenStack con una receta de heat. En este ejercico, vamos a configurar una VPN basada en SSL/TLS usando OpenVPN.
Configuraci√≥n Tenemos dos m√°quinas debian, una que va a actuar como Router llamada vpn_server y la otra como cliente, llamada lan. Para comenzar a realizar el ejercicio, vamos a activar el bit de forward para que nuestra m√°quina lan pueda acceder a internet a trav√©s de vpn_server, para ello cambiamos el valor 0 por el valor 1 del fichero /proc/sys/net/ipv4/ip_forward y creamos una regla NAT en iptables</description>
            <content type="html"><![CDATA[<h2 id="configuraci√≥n-de-openvpn-de-acceso-remoto-con-clave-est√°tica-compartida">Configuraci√≥n de openVPN de acceso remoto con clave est√°tica compartida</h2>
<p>Vamos a levantar un escenario en OpenStack con una <a href="https://fp.josedomingo.org/seguridadgs/u04/escenario_vpn.yaml">receta de heat</a>. En este ejercico, vamos a configurar una VPN basada en SSL/TLS usando OpenVPN.</p>
<h2 id="configuraci√≥n">Configuraci√≥n</h2>
<p>Tenemos dos m√°quinas debian, una que va a actuar como Router llamada <code>vpn_server</code> y la otra como cliente, llamada <code>lan</code>. Para comenzar a realizar el ejercicio, vamos a activar el bit de forward para que nuestra m√°quina <code>lan</code> pueda acceder a internet a trav√©s de <code>vpn_server</code>, para ello cambiamos el valor <code>0</code> por el valor <code>1</code> del fichero <code>/proc/sys/net/ipv4/ip_forward</code> y creamos una regla <code>NAT</code> en <code>iptables</code></p>
<pre><code>sudo nano /proc/sys/net/ipv4/ip_forward

1

sudo iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -j MASQUERADE
</code></pre><p>Por √∫ltimo nos conectamos a <code>lan</code> y comprobamos que tiene conexi√≥n con el exterior</p>
<pre><code>ssh 192.168.100.10

ping www.google.es
PING www.google.es (216.58.209.67) 56(84) bytes of data.
64 bytes from waw02s06-in-f67.1e100.net (216.58.209.67): icmp_seq=1 ttl=112 time=180 ms
--- www.google.es ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 180.366/180.366/180.366/0.000 ms
</code></pre><p>Ahora que tenemos nuestro escenario funcionando, vamos a comenzar a montar nuestra <code>VPN</code>, as√≠ que para empezar vamos a instalar <code>OpenVPN</code> en nuestra m√°quina como el <code>vpn_server</code></p>
<pre><code>sudo apt-get install openvpn
</code></pre><p>El siguiente paso ser√≠a decidir c√≥mo se va a realizar la autenticaci√≥n de los extremos y el cifrado. En este ejercicio realizaremos la forma m√°s sencilla, que es usar una <strong>clave compartida (pre-shared key)</strong>, aunque el uso de certificados es m√°s seguro.</p>
<h2 id="generaci√≥n-de-la-clave">Generaci√≥n de la clave</h2>
<p>Generamos la clave</p>
<pre><code>sudo openvpn --genkey --secret clave.key
</code></pre><h2 id="configuraci√≥n-del-servidor">Configuraci√≥n del servidor</h2>
<p>Movemos la clave generada al directorio <code>/etc/openvpn</code> y creamos el archivo <code>/etc/openvpn/server.conf</code></p>
<pre><code>mv clave.key /etc/openvpn

sudo nano /etc/openvpn/server.conf

dev tun
ifconfig 10.10.10.1 10.10.10.2
secret clave.key
</code></pre><h2 id="configuraci√≥n-del-cliente">Configuraci√≥n del cliente</h2>
<p>Ahora vamos a pasar a la confgiuraci√≥n del cliente y lo primero que haremos ser√° instalar <code>openvpn</code> y copiar en el directorio <code>/etc/openvpn</code> del cliente la clave generada anteriormente.</p>
<pre><code>debian@lan:~$ sudo apt-get install openvpn

debian@vpn-server:~$ scp clave.key debian@192.168.100.10:/home/debian

debian@lan:~$ sudo cp clave.key /etc/openvpn/
</code></pre><p>Ahora que tenemos todo preparado, vamos a crear un fichero de configuraci√≥n en el cliente en la ruta <code>/etc/openvpn</code> llamado <code>client.conf</code> y le introducimos la siguiente configuraci√≥n</p>
<pre><code>sudo nano /etc/openvpn/client.conf

remote 172.22.201.64
dev tun
ifconfig 10.10.10.2 10.10.10.1
route 192.168.100.0 255.255.255.0
secret clave.key
</code></pre><ul>
<li><strong>remote:</strong> Aqu√≠ introducimos la IP de la interfaz de red que accede a internet del servidor VPN (en mi caso ser√≠a la 172.22.201.64).</li>
<li><strong>ifconfig:</strong> Introducimos las IP de las interfaces de t√∫nel. No tienen que coincidir con las IP de nuetra red. (En este caso les he puesto la 10.10.10.1 y 10.10.10.2)</li>
<li><strong>route:</strong> A√±ade a la tabla de encaminamiento del cliente una entrada que permita acceder a los recursos de la red local remota (En este ejemplo nuestra red es la <code>192.168.100.0/24</code>).</li>
</ul>
<h2 id="establecimiento-de-la-vpn">Establecimiento de la VPN</h2>
<p>Para establecer la <code>VPN</code> hay que arrancar <code>OpenVPN</code> en ambos extremos y configuramos <code>OpenVPN</code> para que lea los archivos <code>*.conf</code> del directorio <code>/etc/openvpn</code>, as√≠ que para configurar esto deberemos editar el fichero <code>/etc/default/openvpn</code> y descomentamops la l√≠nea <code>AUTOSTART=&quot;all&quot;</code> y reiniciamos los siguientes servicios</p>
<pre><code>debian@vpn-server:~$ sudo nano /etc/default/openvpn
[...]
AUTOSTART=&quot;all&quot;
[...]
debian@vpn-server:~$ sudo systemctl daemon-reload
debian@vpn-server:~$ sudo systemctl start openvpn

debian@lan:~$ sudo nano /etc/default/openvpn
[...]
AUTOSTART=&quot;all&quot;
[...]
debian@lan:~$ sudo systemctl daemon-reload
debian@lan:~$ sudo systemctl start openvpn
</code></pre><p>Cuando se haya establecido la VPN se habr√° creado una interfaz de tipo t√∫nel en ambas m√°quinas que simulan un enlace PPP. Vamos a compro bar que se han creado las interfaces de red de tipo t√∫nel.</p>
<pre><code>debian@vpn-server:~$ ip a
[...]
4: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100
    link/none 
    inet 10.10.10.1 peer 10.10.10.2/32 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::8894:d8a4:ed6a:37a3/64 scope link stable-privacy 
       valid_lft forever preferred_lft forever

debian@lan:~$ ip a
[...]
3: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100
    link/none 
    inet 10.10.10.2 peer 10.10.10.1/32 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::e3cb:45d6:17ab:7fb3/64 scope link stable-privacy 
       valid_lft forever preferred_lft forever
</code></pre><p>A parte de las interfaces de red, se han creado tambi√©n las reglas en la tabla de encaminamiento, que permiten el tr√°fico con la m√°quina <code>10.10.10.1</code> y con la red remota <code>192.168.100.0/24</code></p>
<pre><code>debian@vpn-server:~$ sudo ip r
default via 10.0.0.1 dev eth0 
10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.7 
10.10.10.2 dev tun0 proto kernel scope link src 10.10.10.1 
169.254.169.254 via 10.0.0.1 dev eth0 
192.168.100.0/24 dev eth1 proto kernel scope link src 192.168.100.2

debian@lan:~$ sudo ip r
default via 192.168.100.2 dev eth0 
10.10.10.1 dev tun0 proto kernel scope link src 10.10.10.2 
169.254.169.254 via 192.168.100.1 dev eth0 
192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.10
</code></pre><p>A partir de este momento el cliente podr√≠a usar todos los recursos de nuestra red local de forma segura, ya que todo el tr√°fico que pase por ah√≠ ir√° cifrado a trav√©s del t√∫nel.</p>
]]></content>
        </item>
        
        <item>
            <title>Apuntes de Proxy, Proxy Inverso y Balanceador de carga</title>
            <link>https://juanan219.github.io/posts/2021/02/apuntes-de-proxy-proxy-inverso-y-balanceador-de-carga/</link>
            <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/apuntes-de-proxy-proxy-inverso-y-balanceador-de-carga/</guid>
            <description>Proxy/Cach√©   Proxy: Proporcionaconexi√≥n a internet cuando no tenemos enrutadores / NAT. Por lo tanto gestiona la comunicaci√≥n HTTP y la podemos filtrar.
  Cach√©: Guarda ficheros de internet para que las futuras b√∫squedas de esos ficheros en la red no sea necesario volver a descargarlos de internet, sino descargarlosn directamente desde el proxy.
  Herramientas   DansGuardian: es un software de filtro de contenido, dise√±ado para controlar el acceso a sitios web.</description>
            <content type="html"><![CDATA[<h2 id="proxycach√©">Proxy/Cach√©</h2>
<ul>
<li>
<p><strong>Proxy:</strong> Proporcionaconexi√≥n a internet cuando no tenemos enrutadores / NAT. Por lo tanto gestiona la comunicaci√≥n HTTP y la podemos filtrar.</p>
</li>
<li>
<p><strong>Cach√©:</strong> Guarda ficheros de internet para que las futuras b√∫squedas de esos ficheros en la red no sea necesario volver a descargarlos de internet, sino descargarlosn directamente desde el proxy.</p>
</li>
</ul>
<h3 id="herramientas">Herramientas</h3>
<ul>
<li>
<p><strong>DansGuardian:</strong> es un software de filtro de contenido, dise√±ado para controlar el acceso a sitios web.</p>
</li>
<li>
<p><strong>Sarg (Squid Analysis Report Generator):</strong> es una herramienta que permite a los administradores de sistemas ver de una manera sencilla y amigable qu√© sitios de Internet visitan los usuarios de la red local usando los logs de Squid.</p>
</li>
</ul>
<h2 id="proxy-inverso">Proxy inverso</h2>
<ul>
<li>
<p>Un proxy inverso es un tipo de servidor proxy que recupera los recursos en nombre de un cliente desde uno o m√°s servidores. Por lo tanto el cliente hace la petici√≥n al puerto 80 del proxy y √©ste es el que hace la petici√≥n al servidor web que normalmente est√° en una red interna no accesible desde el cliente.</p>
</li>
<li>
<p>Un proxy inverso tambi√©n  puede teer funciones de <strong>cach√©</strong> cuando es capaz de guardar informai·πïon de los servidores internos y ofrecerla en las pr√≥ximas peticiones.</p>
</li>
<li>
<p>Teienen proxy inverso <code>apache2</code>, <code>nginx</code>, <code>varnish</code>, <code>traefikck</code>, etc&hellip;</p>
</li>
</ul>
<h2 id="balanceador-de-varga">Balanceador de varga</h2>
<ul>
<li>Un <strong>Balanceador de carga</strong> fundamentalmente es un dispositivo de hardware o software que se pone al frente de un conjunto de servidores que atienden a una aplicaci√≥n y tal como su nombre lo indica, asigna o balancea las solicitudes que llegan de los clientes a los servidores usando alg√∫n algoritmo.</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Rendimiento de servidor Web con cach√© Varnish</title>
            <link>https://juanan219.github.io/posts/2021/02/rendimiento-de-servidor-web-con-cach%C3%A9-varnish/</link>
            <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/rendimiento-de-servidor-web-con-cach%C3%A9-varnish/</guid>
            <description>Seg√∫n las pruebas de rendimiento que se han realizado con el comando ab a varias configuraciones de servidores webs sirviendo un Wordpress, la mejor configuraci√≥n para este tipo de escenarios es PHP-FPM (Socket Unix) + NGINX.
El comando usado para las pruebas es el siguiente:
ab -t 10 -c 200 -k http://172.22.x.x/wordpress/index.phpAumento de rendimiento en la ejecuci√≥n de scripts PHP  Tarea 1:  Vamos a configurar una m√°quina con la configuraci√≥n ganadora: PHP-FPM (Socket Unix) + NGINX.</description>
            <content type="html"><![CDATA[<p>Seg√∫n las pruebas de rendimiento que se han realizado con el comando <code>ab</code> a varias configuraciones de servidores webs sirviendo un Wordpress, la mejor configuraci√≥n para este tipo de escenarios es <code>PHP-FPM (Socket Unix) + NGINX</code>.</p>
<p>El comando usado para las pruebas es el siguiente:</p>
<pre><code>ab -t 10 -c 200 -k http://172.22.x.x/wordpress/index.php
</code></pre><h2 id="aumento-de-rendimiento-en-la-ejecuci√≥n-de-scripts-php">Aumento de rendimiento en la ejecuci√≥n de scripts PHP</h2>
<ul>
<li><strong>Tarea 1:</strong></li>
</ul>
<p>Vamos a configurar una m√°quina con la configuraci√≥n ganadora: <code>PHP-FPM (Socket Unix) + NGINX</code>. Para ello vamos a ejecutar una <a href="https://github.com/josedom24/ansible_nginx_fpm_php">receta de ansible</a> y vamos a terminar la configuraci√≥n del sitio.</p>
<p>Primero instalamos <code>ansible</code> y <code>git</code></p>
<pre><code>sudo apt-get update
sudo apt-get install ansible
sudo apt-get install git
</code></pre><p>Clonamos el repositorio</p>
<pre><code>mkdir GitHub
cd GitHub/
git clone https://github.com/josedom24/ansible_nginx_fpm_php
</code></pre><p>He creado una m√°quina en <code>vagrant</code> con la ip <code>192.168.1.113</code> y he modificado el fichero hosts del repositorio que acabo de clonar y he cambiadp la IP que trae configurada, por la ip de mi m√°quina</p>
<pre><code>nano hosts

[servidores_web]
nodo1 ansible_ssh_host=172.22.201.58 ansible_python_interpreter=/usr/bin/python3
</code></pre><p>Tambi√©n he cambiado el usuario remoto y he a√±adido la clave de vagrant a <code>ssh-agent</code></p>
<pre><code>nano ansible.cfg

[defaults]
inventory = hosts
remote_user = vagrant
host_key_checking = False

ssh-add .vagrant/machines/server/virtualbox/private_key
</code></pre><p>ab -t 10 -c 200 -k http:/127.0.0.1/wordpress/index.php
Ejecutamos el playbook y esperamos a que termine todo el proceso</p>
<pre><code>ansible-playbook site.yaml
</code></pre><p>Esta es la configuraci√≥n de wordpress
<a href="https://www.youtube.com/watch?v=W3i6eIJQ89M"><img src="https://i.ytimg.com/vi/W3i6eIJQ89M/maxresdefault.jpg" alt="V√≠deo"></a></p>
<ul>
<li><strong>Tarea 2:</strong></li>
</ul>
<p>Ahora vamos a realizar las pruebas de rendimiento desde la misma m√°quina, es decir, vamos a ejecutar instrucciones similares a:</p>
<pre><code>ab -t 10 -c 200 -k http:/127.0.0.1/wordpress/index.php
</code></pre><p>Pero antes de usar ese comando deberemos instalar el paquete en el que se encuentra, en este caso es <code>apache2-utils</code></p>
<pre><code>sudo apt-get install apache2-utils
</code></pre><ul>
<li>
<p>Vamos a realizar dicha prueba con diferentes valores de concurrencia:</p>
<ul>
<li><strong>50:</strong></li>
</ul>
</li>
</ul>
<pre><code>ab -t 10 -c 50 -k http:/127.0.0.1/wordpress/index.php
[...]
Requests per second:    115.25 [#/sec] (mean)
[...]
</code></pre><pre><code>* **100:**
</code></pre>
<pre><code>ab -t 10 -c 100 -k http://127.0.0.1/wordpress/index.php
[...]
Requests per second:    127.95 [#/sec] (mean)
[...]
</code></pre><pre><code>* **200:**
</code></pre>
<pre><code>ab -t 10 -c 200 -k http://127.0.0.1/wordpress/index.php
[...]
Requests per second:    9519.44 [#/sec] (mean)
[...]
</code></pre><pre><code>* **250:**
</code></pre>
<pre><code>ab -t 10 -c 250 -k http://127.0.0.1/wordpress/index.php
[...]
Requests per second:    8189.23 [#/sec] (mean)
[...]
</code></pre><pre><code>* **500:**
</code></pre>
<pre><code>ab -t 10 -c 500 -k http://127.0.0.1/wordpress/index.php
[...]
Requests per second:    9385.39 [#/sec] (mean)
[...]
</code></pre><p>La media de las respuestas por segundo es de 5444,402.</p>
<ul>
<li><strong>Tarea 3:</strong></li>
</ul>
<p>Ahora vamos a configurar la <code>cach√© Varnish</code>, la cual es un proxy inverso que estar√° escuchando en el puerto 80 y se va a comunicar con el servidor web por el puerto 8080. Para instalar <code>Varnish</code> simplemente lo podemos hacer con apt</p>
<pre><code>sudo apt-get install varnish
</code></pre><p>Una vez instalado <code>varnish</code> en nuestra m√°quina, editaremos el fichero <code>/etc/default/varnish</code> para configurar el demonio y que escuche desde el puerto 80 por la interfaz p√∫blica del servidor.</p>
<pre><code>sudo nano /etc/default/varnish
[...]
DAEMON_OPTS=&quot;-a :80 \
             -T localhost:6082 \
             -f /etc/varnish/default.vcl \
             -S /etc/varnish/secret \
             -s malloc,1G&quot;
[...]
</code></pre><p>Ahora modificaremos la unidad de <code>systemd</code> para que <code>varnish</code> arranque en el puerto 80, para ello vamos a editar el fichero <code>/lib/systemd/system/varnish.service</code> y modificamos al siguiente l√≠nea:</p>
<pre><code>ExecStart=/usr/sbin/varnishd -j unix,user=vcache -F -a :80 -T localhost:6082 -f /etc/varnish/default.vcl -S /etc/varnish/secret -s malloc,1G
</code></pre><p>Por √∫ltimo modificamos el fichero <code>/etc/varnish/default.vcl</code> para que este coja el <code>puerto 8080</code>, en el cual vamos a poner a escucha a nuestro servidor <code>nginx</code></p>
<pre><code>sudo nano /etc/varnish/default.vcl
[...]
backend default {
    .host = &quot;127.0.0.1&quot;;
    .port = &quot;8080&quot;;
}
[...]
</code></pre><p>Y reiniciamos tanto <code>varnish</code> como <code>systemd</code></p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl restart varnish
</code></pre><p>Ahora vamos a modificar nuestro virtualhost, lo pondremos a escuchar en el <code>puerto 8080</code> y recargamos el servicio</p>
<pre><code>sudo nano /etc/nginx/sites-available/default
server {
        listen 8080 ;
[...]

sudo systemctl restart nginx.service
</code></pre><p>Comprobamos que varnish est√° escuchando en el <code>puerto 80</code> y nginx est√° en el <code>puerto 8080</code></p>
<pre><code>sudo netstat -putan
[...]
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      700/nginx: master p 
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      378/varnishd
[...]
</code></pre><p>Ahora que lo tenemos todo funcionando, vamos a volver a realizar las mismas pruebas de concurrencia de antes y vamos a comparar los resultados</p>
<ul>
<li><strong>50:</strong></li>
</ul>
<pre><code>ab -t 10 -c 50 -k http://127.0.0.1/
[...]
Requests per second:    17403.75 [#/sec] (mean)
[...]
</code></pre><ul>
<li><strong>100:</strong></li>
</ul>
<pre><code>ab -t 10 -c 100 -k http://127.0.0.1/
[...]
Requests per second:    16256.04 [#/sec] (mean)
[...]
</code></pre><ul>
<li><strong>200:</strong></li>
</ul>
<pre><code>ab -t 10 -c 200 -k http://127.0.0.1/
[...]
Requests per second:    14731.21 [#/sec] (mean)
[...]
</code></pre><ul>
<li><strong>250:</strong></li>
</ul>
<pre><code>ab -t 10 -c 250 -k http://127.0.0.1/
[...]
Requests per second:    15370.86 [#/sec] (mean)
[...]
</code></pre><p>La media de peticiones con <code>varnish</code> es de 15940,465 peticiones por segundo, mientras que sin √©l la media era de 5444,402 peticiones por segundo.</p>
<p>Si comprobamos el fichero <code>/var/log/nginx/access.log</code> podemos ver que s√≥lo se registra en el log la primera petici√≥n, ya que las siguientes peticiones las gestiona varnish.</p>
<pre><code>sudo tail /var/log/nginx/access.log
[...]
127.0.0.1 - - [19/Feb/2021:09:39:27 +0000] &quot;GET /wordpress/index.php HTTP/1.1&quot; 301 5 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:39:36 +0000] &quot;GET / HTTP/1.1&quot; 200 3488 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:41:49 +0000] &quot;GET / HTTP/1.1&quot; 200 3488 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:46:56 +0000] &quot;GET / HTTP/1.1&quot; 200 3488 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot;
127.0.0.1 - - [19/Feb/2021:09:47:06 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 199 &quot;http://www.juanan.es/&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot;
</code></pre><p>Los registros de <code>varnish</code> se guardan en el fichero <code>/var/log/varnish/varnishncsa.log</code></p>
<pre><code>sudo tail /var/log/varnish/varnishncsa.log
127.0.0.1 - - [19/Feb/2021:09:42:55 +0000] &quot;GET http://127.0.0.1/ HTTP/1.0&quot; 200 8667 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:42:55 +0000] &quot;GET http://127.0.0.1/ HTTP/1.0&quot; 200 8667 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:42:55 +0000] &quot;GET http://127.0.0.1/ HTTP/1.0&quot; 200 8667 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:42:55 +0000] &quot;GET http://127.0.0.1/ HTTP/1.0&quot; 200 8667 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:42:55 +0000] &quot;GET http://127.0.0.1/ HTTP/1.0&quot; 200 8667 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:42:55 +0000] &quot;GET http://127.0.0.1/ HTTP/1.0&quot; 200 8667 &quot;-&quot; &quot;ApacheBench/2.3&quot;
127.0.0.1 - - [19/Feb/2021:09:42:55 +0000] &quot;GET http://127.0.0.1/ HTTP/1.0&quot; 200 8667 &quot;-&quot; &quot;ApacheBench/2.3&quot;
172.22.4.124 - - [19/Feb/2021:09:46:56 +0000] &quot;GET http://www.juanan.es/ HTTP/1.1&quot; 200 3476 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot;
172.22.4.124 - - [19/Feb/2021:09:47:06 +0000] &quot;GET http://www.juanan.es/favicon.ico HTTP/1.1&quot; 404 188 &quot;http://www.juanan.es/&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot;
172.22.4.124 - - [19/Feb/2021:09:47:40 +0000] &quot;GET http://www.juanan.es/ HTTP/1.1&quot; 200 3476 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot;
</code></pre>]]></content>
        </item>
        
        <item>
            <title>Practica iSCSI</title>
            <link>https://juanan219.github.io/posts/2021/02/practica-iscsi/</link>
            <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/practica-iscsi/</guid>
            <description>Creaci√≥n de targets en Linux Primero vamos a crear un target con una LUN, para ello primero vamos a instalar el paquete tgt en el servidor
sudo apt-get install tgt Ahora vamos a definir dos targets, uno para un cliente Linux y otro para un cliente Windows. Para definirlos de forma persistente, deberemos editar el fichero /etc/tgt/targets.conf y reiniciamos el servicio tgt
sudo nano etc/tgt/targets.conf [...] &amp;lt;target iqn.2021-02.es.juanan:target1&amp;gt; backing-store /dev/sdb &amp;lt;/target&amp;gt; &amp;lt;target iqn.</description>
            <content type="html"><![CDATA[<h2 id="creaci√≥n-de-targets-en-linux">Creaci√≥n de targets en Linux</h2>
<p>Primero vamos a crear un target con una LUN, para ello primero vamos a instalar el paquete <code>tgt</code> en el servidor</p>
<pre><code>sudo apt-get install tgt
</code></pre><p>Ahora vamos a definir dos targets, uno para un cliente Linux y otro para un cliente Windows. Para definirlos de forma persistente, deberemos editar el fichero <code>/etc/tgt/targets.conf</code> y reiniciamos el servicio <code>tgt</code></p>
<pre><code>sudo nano etc/tgt/targets.conf
[...]
&lt;target iqn.2021-02.es.juanan:target1&gt;
        backing-store /dev/sdb
&lt;/target&gt;
&lt;target iqn.2021-02.es.juanan:target2&gt;
        backing-store /dev/sdc
&lt;/target&gt;

sudo systemctl restart tgt
</code></pre><p>Podemos ver los targets con el siguiente comando</p>
<pre><code>sudo tgtadm --lld iscsi --op show  --mode target

Target 1: iqn.2021-02.es.juanan:target1
    System information:
        Driver: iscsi
        State: ready
    I_T nexus information:
    LUN information:
        LUN: 0
            Type: controller
            SCSI ID: IET     00010000
            SCSI SN: beaf10
            Size: 0 MB, Block size: 1
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: null
            Backing store path: None
            Backing store flags: 
        LUN: 1
            Type: disk
            SCSI ID: IET     00010001
            SCSI SN: beaf11
            Size: 1074 MB, Block size: 512
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/sdb
            Backing store flags: 
    Account information:
    ACL information:
        ALL
Target 2: iqn.2021-02.es.juanan:target2
    System information:
        Driver: iscsi
        State: ready
    I_T nexus information:
    LUN information:
        LUN: 0
            Type: controller
            SCSI ID: IET     00020000
            SCSI SN: beaf20
            Size: 0 MB, Block size: 1
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: null
            Backing store path: None
            Backing store flags: 
        LUN: 1
            Type: disk
            SCSI ID: IET     00020001
            SCSI SN: beaf21
            Size: 1074 MB, Block size: 512
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/sdc
            Backing store flags: 
    Account information:
    ACL information:
        ALL
</code></pre><p>Ahora nos vamos a conectar al cliente Linux e instalaremos la herramienta <code>open-iscsi</code></p>
<pre><code>sudo apt-get install open-iscsi
</code></pre><p>Como podemos ver, esta m√°quina tiene solo 1 disco duro</p>
<pre><code>lsblk -f
NAME   FSTYPE LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINT
sda                                                                     
‚îú‚îÄsda1 ext4         983742b1-65a8-49d1-a148-a3865ea09e24   16.1G     7% /
‚îú‚îÄsda2                                                                  
‚îî‚îÄsda5 swap         04559374-06db-46f1-aa31-e7a4e6ec3286                [SWAP]
</code></pre><p>Vamos a buscar los targets disponibles</p>
<pre><code>sudo iscsiadm --mode discovery --type sendtargets --portal server
192.168.1.113:3260,1 iqn.2021-02.es.juanan:target1
192.168.1.113:3260,1 iqn.2021-02.es.juanan:target2
</code></pre><p>Cuando sepamos los targets que tiene el servidor <code>server</code> disponibles, podemos conectarnos, ya que no tienen autenticaci√≥n, de momento</p>
<pre><code>sudo iscsiadm --mode node -T iqn.2021-02.es.juanan:target1 --portal server --login
</code></pre><p>Despu√©s del comando anterior, esta es la nueva salida de <code>lsblk -f</code></p>
<pre><code>lsblk -f
NAME   FSTYPE LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINT
sda                                                                     
‚îú‚îÄsda1 ext4         983742b1-65a8-49d1-a148-a3865ea09e24   16.1G     7% /
‚îú‚îÄsda2                                                                  
‚îî‚îÄsda5 swap         04559374-06db-46f1-aa31-e7a4e6ec3286                [SWAP]
sdb
</code></pre><p>Le damos formato y lo montamos</p>
<pre><code>sudo mkfs.ext4 /dev/sdb
mke2fs 1.44.5 (15-Dec-2018)
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: 97ec7dd7-1a01-4ab9-8572-4607066b6f2b
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

sudo mount /dev/sdb /mnt

lsblk -f
NAME   FSTYPE LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINT
sda                                                                     
‚îú‚îÄsda1 ext4         983742b1-65a8-49d1-a148-a3865ea09e24   16.1G     7% /
‚îú‚îÄsda2                                                                  
‚îî‚îÄsda5 swap         04559374-06db-46f1-aa31-e7a4e6ec3286                [SWAP]
sdb    ext4         97ec7dd7-1a01-4ab9-8572-4607066b6f2b  906.2M     0% /mnt
</code></pre><h2 id="montar-targets-de-forma-autm√°tica-con-systemd-mount">Montar targets de forma autm√°tica con systemd mount</h2>
<p>Para montar los discos duros de iSCSI de forma permanente en unestro cliente Linux vamos a usar <code>systemd mount</code>, para ello modificaremos el fichero <code>/etc/iscsi/iscsid.conf</code>, comentamos la l√≠nea 43 y descomentamos la 40</p>
<pre><code>sudo nano /etc/iscsi/iscsid.conf
[...]
node.startup = automatic
[...]
# node.startup = manual
[...]

sudo systemctl restart iscsi
</code></pre><p>Ahora creamos la unidad en <code>systemctl</code>, para ello creamos un fichero en la ruta <code>/etc/systemd/system</code></p>
<pre><code>sudo nano discored1.mount

[Unit]
Description= Se monta el target1 de iscsi

[Mount]
What=/dev/sdb
Where=/discored1
Type=ext4
Options=_netdev

[Install]
WantedBy=multi-user.target
</code></pre><p>Ahora reiniciamos los servicios, montamos el disco y creamos un enlace simb√≥lico para que se monte autom√°ticamente en el arranque, para realizar todo esto, el disco que queremos tiene que estar montado</p>
<pre><code>sudo systemctl daemon-reload
sudo iscsiadm --mode node -T iqn.2021-02.es.juanan:target1 --portal server --login
sudo systemctl start discored1.mount
sudo systemctl enable discored1.mount
</code></pre><p>Comprobamos si se han realizado los cambios</p>
<pre><code>lsblk -f
NAME   FSTYPE LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINT
sda                                                                     
‚îú‚îÄsda1 ext4         983742b1-65a8-49d1-a148-a3865ea09e24   16.1G     7% /
‚îú‚îÄsda2                                                                  
‚îî‚îÄsda5 swap         04559374-06db-46f1-aa31-e7a4e6ec3286                [SWAP]
sdb    ext4         97ec7dd7-1a01-4ab9-8572-4607066b6f2b  906.2M     0% /discored1
</code></pre><p>Ahora reiniciamos y volveremos a comprobar</p>
<pre><code>sudo reboot

lsblk -f
NAME   FSTYPE LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINT
sda                                                                     
‚îú‚îÄsda1 ext4         983742b1-65a8-49d1-a148-a3865ea09e24   16.1G     7% /
‚îú‚îÄsda2                                                                  
‚îî‚îÄsda5 swap         04559374-06db-46f1-aa31-e7a4e6ec3286                [SWAP]
sdb    ext4         97ec7dd7-1a01-4ab9-8572-4607066b6f2b  906.2M     0% /discored1
sdc
</code></pre><h2 id="montar-target-en-windows-con-autenticaci√≥n-chap">Montar target en Windows con autenticaci√≥n CHAP</h2>
<p>Primero vamos a modificar de nuevo el fichero <code>/etc/tgt/targets.conf</code> en el server de iSCSI para introducir el usuario y la contrase√±a del target. Cuando hagamos las modificaciones, reiniciamos el servicio</p>
<pre><code>sudo nano /etc/tgt/targets.conf
[...]
&lt;target iqn.2021-02.es.juanan:target2&gt;
        backing-store /dev/sdc
        incominguser juanan juanan_usuario
&lt;/target&gt;

sudo systemctl restart tgt.service 
</code></pre><p>Ahora vamos a montar el disco <code>sdc</code> en windows, para ello nos abrimos el <code>Panel de control</code> &gt; <code>Sistema y Seguridad</code> &gt; <code>Herramientas Administrativas</code> &gt; <code>Iniciador iSCSI</code>. Cuando estemos en este punto, Windows nos preguntar√° si queremos iniciar el servicio <code>iSCSI</code> y le tendremos que decir que s√≠.</p>
<p><img src="/iSCSI/2.png" alt="Captura 2"></p>
<p>Ahora simplemente en la secci√≥n <code>Destinos</code> escribimos el nombre de nuestro server en el cuadro llamado <code>Destino</code> y le damos al bot√≥n llamado <code>Conexi√≥n R√°pida...</code></p>
<p><img src="/iSCSI/3.png" alt="Captura 3"></p>
<p>Ahora que nuestro Window ha detectado a nuestro servidor, vamos a conectar el disco duro sdc, para ello seleccionamos el target al que nos queremos conectar y le damos al bot√≥n <code>Conectar</code>. Si nos intentamos conectar, sin m√°s, nos va a aparecer un error de autenticaci√≥n</p>
<p><img src="/iSCSI/4.png" alt="Captura 4"></p>
<p>Para iniciar sesi√≥n con los par√°metros que le hemos configurado anteriormente en el server, nos intentamos conectar igual que antes, pero con la diferencia de que deberemos pulsar el bot√≥n de <code>Opciones Avanzadas...</code> &gt; <code>Habilitar inicio de sesi√≥n CHAP</code> y escribimos las credenciales correctas.</p>
<p><img src="/iSCSI/5.png" alt="Captura 5"></p>
<p>Como podemos ver, ha cambiado el estado del <code>target2</code>, el cual ha pasado de estar <code>Inactivo</code> a estar <code>Conectado</code></p>
<p><img src="/iSCSI/6.png" alt="Captura 6"></p>
<p>Ahora vamos a comprobar que tenemos ese disco duro montado, para ello nos dirigimos a <code>Crear y  formatear particiones del disco duro</code> y lo primero que nos aparecer√° es una ventana avis√°ndonos de que tenemos un disco duro nuevo, pero que no tiene ninguna partici√≥n ni formato</p>
<p><img src="/iSCSI/7.png" alt="Captura 7"></p>
<p>Para cpmprobar que podemos hacer cambios en el disco, he creado una partici√≥n</p>
<p><img src="/iSCSI/8.png" alt="Captura 8"></p>
]]></content>
        </item>
        
        <item>
            <title>Apuntes iSCSI</title>
            <link>https://juanan219.github.io/posts/2021/02/apuntes-iscsi/</link>
            <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/apuntes-iscsi/</guid>
            <description>Storage Area Network (SAN) Redes de almacenamiento   Es una red de almacenamiento que proporciona dispositivos de bloques a los servidores, esta red es una red infependiente a la red local de nuestra organizaci√≥n.
  Los elementos t√≠picos de una SAN son:
  Red de alta velocidad (cobre o fibra √≥ptica)
  Equipos o servidores que proporcionan el almacenamiento
  Servidores que usan los dispositivos de bloques</description>
            <content type="html"><![CDATA[<h2 id="storage-area-network-san">Storage Area Network (SAN)</h2>
<h3 id="redes-de-almacenamiento">Redes de almacenamiento</h3>
<ul>
<li>
<p>Es una red de almacenamiento que proporciona dispositivos de bloques a los servidores, esta red es una red infependiente a la red local de nuestra organizaci√≥n.</p>
</li>
<li>
<p>Los elementos t√≠picos de una SAN son:</p>
<ul>
<li>
<p>Red de alta velocidad (cobre o fibra √≥ptica)</p>
</li>
<li>
<p>Equipos o servidores que proporcionan el almacenamiento</p>
</li>
<li>
<p>Servidores que usan los dispositivos de bloques</p>
</li>
</ul>
</li>
<li>
<p>Los protocolos m√°s usados en este tipo de redes son:</p>
<ul>
<li>
<p>iSCSI</p>
</li>
<li>
<p>Fibre Channel Protocol (FCP)</p>
</li>
</ul>
</li>
</ul>
<h4 id="esquema-de-ejemplo-de-una-san">Esquema de ejemplo de una SAN</h4>
<p><img src="/iSCSI/1.png" alt="Captura 1"></p>
<h2 id="iscsi">iSCSI</h2>
<ul>
<li>
<p>Es un protocolo que se usa sobre todo en redes de almacenamiento (aunque para usar iSCSI no es imprescindible tener una SAN, ser√≠a lo recomendable, ya que la SAN nos proporciona un mecanismo de aislamiento adecuado para que podamos usar dispositivos de bloques de una forma m√°s segura), pero tambi√©n se puede usar en una red local.</p>
</li>
<li>
<p>Nos proporciona acceso a dispositivos de bloques sobre TCP/IP</p>
</li>
<li>
<p>Alternativa econ√≥mica a FCP</p>
</li>
<li>
<p>Usado habitualmente en redes con velocidades de 1 Gbps o 10 Gbps</p>
</li>
</ul>
<h3 id="elementos-iscsi">Elementos iSCSI</h3>
<ul>
<li>
<p><strong>Unidad L√≥gica (LUN):</strong> Es un dispositivo de bloques a compartir por el servidor iSCSI (Por ejemplo 3 discos duros que hay en el servidor iSCSI)</p>
</li>
<li>
<p><strong>Target:</strong> Recurso a compartir desde el servidor. Un target incluye uno o varios LUN. (Explicaci√≥n: El target contiene los 3 discos duros del servidor para cuando el cliente se conecte, use dicho target, por lo que el cliente tiene 3 discos duros adicionales en su sistema operativo a trav√©s de una sola conexi√≥n. De forma alternativa, podemos plantear que cada una de las conexiones tenga su dispositivo de forma independiente, por lo que en este caso, el cliente tendr√≠a 3 targets con 3 conexiones independientes)</p>
</li>
<li>
<p><strong>Initiator:</strong> Cliente iSCSI</p>
</li>
<li>
<p><strong>Multipath:</strong> Varias rutas entre initiator y servidor para garantizar la disponibilidad de la conexi√≥n, es decir, si tenemos varias formas de conectar el cliente con el servidor, se har√≠a uso de esta caracter√≠stica, ya que si no est√° disponible la conexi√≥n por una ruta, se usa la ruta alternativa.</p>
</li>
<li>
<p>IQN es el formato m√°s extendido para la descripci√≥n de los recursos. Por ejemplo: <code>iqn.2020-01.es.tinaja:sdb4</code> (iqn.[fecha significativa].[nombre a la inversa del dominio o servidor]:[LUN])</p>
</li>
<li>
<p><strong>iSNS:</strong> Protocolo que permite gestionar recursos de iSCSI como si fuera FCP</p>
</li>
</ul>
<h3 id="implementaciones-de-iscsi">Implementaciones de iSCSI</h3>
<ul>
<li>
<p>iSCSI tiene soporte en la mayor√≠a de sistemas operativos</p>
</li>
<li>
<p>En Linux usamos <code>open-iscsi</code> como initiator</p>
</li>
<li>
<p>Existen algunas opciones en Linux para el servidor iSCSI:</p>
<ul>
<li>
<p>Linux-IO (LIO) (Versi√≥n implementada en el k√©rnel de Linux)</p>
</li>
<li>
<p>tgt (Es la m√°s usada)</p>
</li>
<li>
<p>scst</p>
</li>
<li>
<p>istgt</p>
</li>
</ul>
</li>
</ul>
<h2 id="demo-iscsi">Demo iSCSI</h2>
<ul>
<li>Instalamos <code>tgt</code></li>
</ul>
<pre><code>sudo apt-get install tgt
</code></pre><ul>
<li>
<p>Hay dos formas de usar este software:</p>
<ul>
<li>
<p>Podemos dirigirnos al directorio <code>/etc/tgt/</code> y definir ah√≠ la configuraci√≥n modificando los ficheros que sean oportunos. De esta manera la configuraci√≥n es permanente, es decir, se guardan los cambios.</p>
</li>
<li>
<p>Desde la l√≠nea de comandos, por lo que al no estar definida la configuraci√≥n en ning√∫n sitio, sino hecha &ldquo;en caliente&rdquo;, no se guardan los cambios a la hora de reiniciar la m√°quina. (Esta es la forma que usaremos en esta demo)</p>
</li>
</ul>
</li>
<li>
<p>Definimos un target:</p>
<ul>
<li><strong>&ndash;lld:</strong> El controlador, en este caso sera <code>iscsi</code> (<code>--lld iscsi</code>)</li>
<li><strong>&ndash;op:</strong> La operaci√≥n que deseamos hacer, en este caso ser√° crear un nuevo target, por lo que el valor ser√° <code>new</code> (<code>--op new</code>)</li>
<li><strong>&ndash;mode:</strong> Lo que queremos crear, en este caso es un target, por lo que el valor es <code>target</code> (<code>--mode target</code>)</li>
<li><strong>&ndash;tid:</strong> El ID de nuestro nuevo target, en este caso le vamos a asignar el id <code>1</code> (<code>--tid 1</code>)</li>
<li><strong>-T:</strong> El nombre del target que vamos a definir, en este caso ser√° <code>iqn.&quot;a√±o-mes de creaci√≥n.dominio:nombre_target&quot;</code> (<code>--T iqn.2021-02.es.juanan:target1</code>)</li>
</ul>
</li>
</ul>
<pre><code>sudo tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2021-02.es.juanan:target1
</code></pre><pre><code>* Si queremos eliminar un target, simplemente ejecutamos el siguiente comando
</code></pre>
<pre><code>sudo tgtadm --lld iscsi --op delete --mode target --tid 1
</code></pre><ul>
<li>
<p>Le a√±adimos un dispositivo de bloques:</p>
<ul>
<li><strong>&ndash;mode logicalunit:</strong> Le decimos que queremos a√±adir una unidad l√≥gica</li>
<li><strong>&ndash;lun 1:</strong> El ID de la unidad l√≥gica que vamos a a√±adir</li>
<li><strong>-b /dev/sdb:</strong> Ruta hacia el dispositivo de bloques que vamos a a√±adir</li>
</ul>
</li>
</ul>
<pre><code>sudo tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b /dev/sdb
</code></pre><ul>
<li>Le a√±adimos un segundo y tercer dispositivo de bloques</li>
</ul>
<pre><code>sudo tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 2 -b /dev/sdc
sudo tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 3 -b /dev/sdd
</code></pre><pre><code>* Si queremos eliminar alguna de las unidades l√≥gicas que hemos a√±adido, ejecutamos el siguiente comando:
</code></pre>
<pre><code>sudo tgtadm --lld iscsi --op delete --mode logicalunit --tid 1 --lun 2
</code></pre><ul>
<li>Comprobamos que el target est√° bien definido</li>
</ul>
<pre><code>sudo tgtadm --lld iscsi --op show --mode target
</code></pre><pre><code>* Salida del comando anterior
</code></pre>
<pre><code>sudo tgtadm --lld iscsi --op show --mode target
Target 1: iqn.2021-02.es.juanan:target1
    System information:
        Driver: iscsi
        State: ready
    I_T nexus information:
    LUN information:
        LUN: 0
            Type: controller
            SCSI ID: IET     00010000
            SCSI SN: beaf10
            Size: 0 MB, Block size: 1
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: null
            Backing store path: None
            Backing store flags: 
        LUN: 1
            Type: disk
            SCSI ID: IET     00010001
            SCSI SN: beaf11
            Size: 1074 MB, Block size: 512
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/sdb
            Backing store flags: 
        LUN: 2
            Type: disk
            SCSI ID: IET     00010002
            SCSI SN: beaf12
            Size: 1074 MB, Block size: 512
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/sdc
            Backing store flags: 
        LUN: 3
            Type: disk
            SCSI ID: IET     00010003
            SCSI SN: beaf13
            Size: 1074 MB, Block size: 512
            Online: Yes
            Removable media: No
            Prevent removal: No
            Readonly: No
            SWP: No
            Thin-provisioning: No
            Backing store type: rdwr
            Backing store path: /dev/sdd
            Backing store flags: 
    Account information:
    ACL information:
</code></pre><ul>
<li>
<p>Explicaci√≥n:</p>
<ul>
<li><strong>Informaci√≥n sobre el target:</strong> Podemos ver que nos muestra el <code>Target 1</code> y su nombre <code>iqn.2021-02.es.juanan:target1</code>. Est√° en modo <code>ready</code> (<code>State: ready</code>) y tiene un controlador <code>iscsi</code> (<code>Driver: iscsi</code>)</li>
</ul>
</li>
</ul>
<pre><code>Target 1: iqn.2021-02.es.juanan:target1
    System information:
        Driver: iscsi
        State: ready
    I_T nexus information:
</code></pre><pre><code>* **Informaci√≥n de las LUN:** En este apartado (que es el m√°s extenso), podemos ver que tenemos definidas 4 LUNs (`LUN 0, LUN 1, LUN 2 y LUN 3`), pero nosotros solo hemos definido 3 LUNs, esto se debe a que la `LUN 0` es una LUN de control, esto quiere decir que en esta LUN solo se guarda las caracter√≠sticas de las LUNs y siempre se define cuando se define un target. En las dem√°s LUNs podemos ver informaci√≥n como el tipo de LUN que es (`Type: disk`), si es un dispositivo extra√≠ble (`Removable media: No`), si esta en modo s√≥lo lectura (`Readonly: No`), si tiene aprovisionamiento ligero (`Thin-provisioning: No`), el dispositivo de bloques que tiene asociado (`Backing store path: /dev/sdb`), el modo en el que se encuentra (`Backing store type: rdwr`), etc...
</code></pre>
<pre><code>LUN: 0
    Type: controller
    SCSI ID: IET     00010000
    SCSI SN: beaf10
    Size: 0 MB, Block size: 1
    Online: Yes
    Removable media: No
    Prevent removal: No
    Readonly: No
    SWP: No
    Thin-provisioning: No
    Backing store type: null
    Backing store path: None
    Backing store flags: 
LUN: 1
    Type: disk
    SCSI ID: IET     00010001
    SCSI SN: beaf11
    Size: 1074 MB, Block size: 512
    Online: Yes
    Removable media: No
    Prevent removal: No
    Readonly: No
    SWP: No
    Thin-provisioning: No
    Backing store type: rdwr
    Backing store path: /dev/sdb
    Backing store flags: 
</code></pre><pre><code>* **Informaci√≥n adicional:** Este comando tambi√©n nos muestra informaci√≥n sobre la cuenta de acceso y sobre las ACL si las tuvieramos
</code></pre>
<pre><code>Account information:
ACL information:
</code></pre><ul>
<li>
<p>Podemos hacer accesible al target creado desde todas las interfaces de red o desde interfaces de red espec√≠ficas de nuestra m√°quina. En este caso la haremos accesible a trav√©s de todas las interfaces de red de las que disponga nuestra m√°quina:</p>
<ul>
<li><strong>&ndash;op bind:</strong> Operaci√≥n que nos permite especificar por cu√°les interfaces de red queremos hacer accesible un objeto</li>
<li><strong>&ndash;I ALL:</strong> Le indicamos las interfaces de red por las que queremos hacer accesible este target, en este caso, le hemos puesto el valor <code>ALL</code> para que este target sea accesible por todas las interfaces de red.</li>
</ul>
</li>
</ul>
<pre><code>sudo tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
</code></pre><ul>
<li>Cuando tengamos el target configurado y las interfaces de red por las que es accesible definidas, vamos a pasar a la configuraci√≥n del cliente, ya que, dicho target, deber√≠a ser visible desde el cliente. Para conectar el target al cliente, debemos irnos al cliente e instalar el siguiente paquete</li>
</ul>
<pre><code>sudo apt-get install open-iscsi
</code></pre><pre><code>* Al instalar el paquete, se nos asignar√° un nombre predeterminado, el cual se puede ver en el fichero `/etc/iscsi/initiatorname.iscsi` (Este fichero no se debe editar, a parte, no es necesario editarlo a no ser que lo necesites)
</code></pre>
<pre><code>sudo tail /etc/iscsi/initiatorname.iscsi

InitiatorName=iqn.1993-08.org.debian:01:7eb51324d021
</code></pre><ul>
<li>Ahora que lo tenemos instalado, podemos ver la informaci√≥n:</li>
</ul>
<pre><code>sudo iscsiadm --mode discovery --type sendtargets --portal server

192.168.1.48:3260,1 iqn.2021-02.es.juanan:target1
</code></pre><ul>
<li>Tambi√©n nos podemos conectar al target:</li>
</ul>
<pre><code>sudo iscsiadm --mode node -T iqn.2021-02.es.juanan:target1 --portal server --login
</code></pre><pre><code>* Estas son las entradas del log del kernel (`journalctl -f -k`) que podemos ver cuando nos conectamos. Si nos damos cuenta, es como si le conect√°semos 3 nuevos discos
</code></pre>
<pre><code>Feb 12 20:51:16 initiator kernel: Loading iSCSI transport class v2.0-870.
Feb 12 20:51:16 initiator kernel: iscsi: registered transport (tcp)
Feb 12 20:51:16 initiator kernel: iscsi: registered transport (iser)
Feb 12 22:23:15 initiator kernel: scsi host1: iSCSI Initiator over TCP/IP
Feb 12 22:23:15 initiator kernel: scsi 1:0:0:0: RAID              IET      Controller       0001 PQ: 0 ANSI: 5
Feb 12 22:23:15 initiator kernel: scsi 1:0:0:0: Attached scsi generic sg1 type 12
Feb 12 22:23:15 initiator kernel: scsi 1:0:0:1: Direct-Access     IET      VIRTUAL-DISK     0001 PQ: 0 ANSI: 5
Feb 12 22:23:15 initiator kernel: sd 1:0:0:1: Attached scsi generic sg2 type 0
Feb 12 22:23:15 initiator kernel: sd 1:0:0:1: Power-on or device reset occurred
Feb 12 22:23:15 initiator kernel: scsi 1:0:0:2: Direct-Access     IET      VIRTUAL-DISK     0001 PQ: 0 ANSI: 5
Feb 12 22:23:15 initiator kernel: sd 1:0:0:1: [sdb] 2097152 512-byte logical blocks: (1.07 GB/1.00 GiB)
Feb 12 22:23:15 initiator kernel: sd 1:0:0:2: Attached scsi generic sg3 type 0
Feb 12 22:23:15 initiator kernel: sd 1:0:0:2: Power-on or device reset occurred
Feb 12 22:23:15 initiator kernel: sd 1:0:0:1: [sdb] Write Protect is off
Feb 12 22:23:15 initiator kernel: sd 1:0:0:1: [sdb] Mode Sense: 69 00 10 08
Feb 12 22:23:15 initiator kernel: scsi 1:0:0:3: Direct-Access     IET      VIRTUAL-DISK     0001 PQ: 0 ANSI: 5
Feb 12 22:23:15 initiator kernel: sd 1:0:0:3: Attached scsi generic sg4 type 0
Feb 12 22:23:15 initiator kernel: sd 1:0:0:1: [sdb] Write cache: enabled, read cache: enabled, supports DPO and FUA
Feb 12 22:23:15 initiator kernel: sd 1:0:0:3: Power-on or device reset occurred
Feb 12 22:23:15 initiator kernel: sd 1:0:0:2: [sdc] 2097152 512-byte logical blocks: (1.07 GB/1.00 GiB)
Feb 12 22:23:15 initiator kernel: sd 1:0:0:2: [sdc] Write Protect is off
Feb 12 22:23:15 initiator kernel: sd 1:0:0:2: [sdc] Mode Sense: 69 00 10 08
Feb 12 22:23:15 initiator kernel: sd 1:0:0:2: [sdc] Write cache: enabled, read cache: enabled, supports DPO and FUA
Feb 12 22:23:15 initiator kernel: sd 1:0:0:3: [sdd] 2097152 512-byte logical blocks: (1.07 GB/1.00 GiB)
Feb 12 22:23:15 initiator kernel: sd 1:0:0:3: [sdd] Write Protect is off
Feb 12 22:23:15 initiator kernel: sd 1:0:0:3: [sdd] Mode Sense: 69 00 10 08
Feb 12 22:23:15 initiator kernel: sd 1:0:0:3: [sdd] Write cache: enabled, read cache: enabled, supports DPO and FUA
Feb 12 22:23:15 initiator kernel: sd 1:0:0:2: [sdc] Attached SCSI disk
Feb 12 22:23:15 initiator kernel: sd 1:0:0:1: [sdb] Attached SCSI disk
Feb 12 22:23:15 initiator kernel: sd 1:0:0:3: [sdd] Attached SCSI disk
</code></pre><pre><code>* Esta es la salida del comando `lsblk` antes de conectarnos
</code></pre>
<pre><code>lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0 19.8G  0 disk 
‚îú‚îÄsda1   8:1    0 18.8G  0 part /
‚îú‚îÄsda2   8:2    0    1K  0 part 
‚îî‚îÄsda5   8:5    0 1021M  0 part [SWAP]
</code></pre><pre><code>* Esta es la salida del comando `lsblk` despu√©s de conectarnos
</code></pre>
<pre><code>lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0 19.8G  0 disk 
‚îú‚îÄsda1   8:1    0 18.8G  0 part /
‚îú‚îÄsda2   8:2    0    1K  0 part 
‚îî‚îÄsda5   8:5    0 1021M  0 part [SWAP]
sdb      8:16   0    1G  0 disk 
sdc      8:32   0    1G  0 disk 
sdd      8:48   0    1G  0 disk
</code></pre><ul>
<li>Ahora que los tenemos conectados remotamente a nuestra m√°quina, podemos operar sobre ellos, por ejemplo, si queremos montar uno de los dispositivos (<code>/dev/sdb</code>) de bloques le podemos dar formato <code>ext4</code> y montarlo en <code>/mnt</code></li>
</ul>
<pre><code>sudo mkfs.ext4 /dev/sdb

sudo mount /dev/sdb /mnt

lsblk -f

sdb    ext4         86b14bd0-6953-4996-a1da-f82f5d248b51  906.2M     0% /mnt
</code></pre>]]></content>
        </item>
        
        <item>
            <title>Servidor de correos</title>
            <link>https://juanan219.github.io/posts/2021/02/servidor-de-correos/</link>
            <pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/servidor-de-correos/</guid>
            <description>En esta entrada vamos a configurar un servidor de correos en un VPS, para ello primero deberemos configurar el nombre del servidor de correos, el cual ser√° mail.iesgn16.es, cuyo nombre aparecer√° en el registro MX de nuestro DNS.
Para configurar el mail en nuestro servidor, vamos a instalar postfix
sudo apt-get update sudo apt-get install postfix Durante la instalaci√≥n se nos pedir√° que configuremos el mailname, es decir, el nombre del servidor de correo.</description>
            <content type="html"><![CDATA[<p>En esta entrada vamos a configurar un servidor de correos en un VPS, para ello primero deberemos configurar el nombre del servidor de correos, el cual ser√° <code>mail.iesgn16.es</code>, cuyo nombre aparecer√° en el registro MX de nuestro DNS.</p>
<p>Para configurar el mail en nuestro servidor, vamos a instalar postfix</p>
<pre><code>sudo apt-get update

sudo apt-get install postfix
</code></pre><p>Durante la instalaci√≥n se nos pedir√° que configuremos el <em>mailname</em>, es decir, el nombre del servidor de correo. Cuando lo tengamos configurado, lo podremos ver con el comando</p>
<pre><code>cat /etc/mailname

iesgn16.es
</code></pre><p>Creamos el registro MX y SPF en nuestro DNS</p>
<p><img src="/correo/1.png" alt="Captura 1"></p>
<h2 id="gesti√≥n-de-correos-desde-el-servidor">Gesti√≥n de correos desde el servidor</h2>
<ul>
<li><strong>Tarea 1</strong></li>
</ul>
<p>Vamos a descargarnos la herramienta que nos permita enviar/leer correos que recibamos en nuestro servidor postfix, dicha herramienta se llama <code>mailutils</code> y se instala de la siguiente manera</p>
<pre><code>sudo apt-get install mailutils
</code></pre><p>Ahora que tenemos <code>mailutils</code>, vamos a enviar un correo de prueba</p>
<pre><code>mail -s &quot;Prueba&quot; initiategnat9@gmail.com
Cc: 
Hola, esto es una prueba
</code></pre><p>Cuando enviamos el correo, podemos verlo en el registro de log de postfix</p>
<pre><code>Feb  9 12:24:58 fenix postfix/qmgr[30796]: 9C31561C11: removed
Feb  9 12:31:19 fenix postfix/pickup[30795]: 5285E61C11: uid=1000 from=&lt;debian@fenix.iesgn16.es&gt;
Feb  9 12:31:19 fenix postfix/cleanup[31354]: 5285E61C11: message-id=&lt;20210209123119.5285E61C11@fenix.iesgn16.es&gt;
Feb  9 12:31:19 fenix postfix/qmgr[30796]: 5285E61C11: from=&lt;debian@fenix.iesgn16.es&gt;, size=369, nrcpt=1 (queue active)
Feb  9 12:31:19 fenix postfix/smtp[31356]: 5285E61C11: to=&lt;initiategnat9@gmail.com&gt;, relay=gmail-smtp-in.l.google.com[74.125.140.26]:25, delay=0.54, delays=0.02/0.01/0.31/0.21, dsn=2.0.0, status=sent (250 2.0.0 OK  1612873879 q194si1500502wme.142 - gsmtp)
Feb  9 12:31:19 fenix postfix/qmgr[30796]: 5285E61C11: removed
</code></pre><p>Este es el correo que he recibido en mi gmail</p>
<p><img src="/correo/2.png" alt="Captura 2"></p>
<p>Este es el registro SPF que he tenido que a√±adir a mi servidor DNS</p>
<p><img src="/correo/3.png" alt="Captura 3"></p>
<ul>
<li>
<p><strong>Tarea 2</strong></p>
<ul>
<li><strong>a)</strong> Documenta una prueba de funcionamiento, en la que env√≠es un correo desde el exterior (gmail, hotmail, etc&hellip;) a tu servidor local.</li>
</ul>
</li>
</ul>
<p>Vamos a comprobar que podemos recibir correos desde el exterior hacia nuestros servidor, para ello, primero deberemos tener configurado nuestro nombre de dominio en el fichero <code>/etc/mailname</code>, en mi caso, el nopmbre de dominio ser√≠a <code>iesgn16.es</code>. Ahora revisamos la configuraci√≥n del DNS para que el registro MX <code>mail.iesgn16.es</code> apunte a <code>fenix.iesgn16.es</code> (Que es la m√°quina en la que tengo el servidor de correo).</p>
<p>Cuando todo est√© correcto, hacemos una prueba y enviamos un correo a nuestro usuario del servidor</p>
<p><img src="/correo/4.png" alt="Captura 4"></p>
<p>Lo abrimos desde nuestro servidor con el comando <code>mail</code></p>
<pre><code>mail
&quot;/var/mail/debian&quot;: 1 message 1 new
&gt;N   1 juanan veintidieci Tue Feb  9 13:00 101/4632  RE: Prueba
? 1
Return-Path: &lt;initiategnat9@gmail.com&gt;
X-Original-To: debian@fenix.iesgn16.es
Delivered-To: debian@fenix.iesgn16.es
[...]
Content-Type: text/plain; charset=&quot;UTF-8&quot;
Content-Transfer-Encoding: quoted-printable

Correcto, prueba de correo recibida

--=20
*Fdo: Juan Antonio Reifs Ram=C3=ADrez*
</code></pre><p>Podemos ver el log en el cual se ve que hemos recibido el correo</p>
<pre><code>Feb  9 13:00:19 fenix postfix/smtpd[31853]: connect from mail-ej1-f49.google.com[209.85.218.49]
Feb  9 13:00:19 fenix postfix/smtpd[31853]: CF3EB61A7B: client=mail-ej1-f49.google.com[209.85.218.49]
Feb  9 13:00:19 fenix postfix/cleanup[31858]: CF3EB61A7B: message-id=&lt;CAFPV5c77w-0rLEWJGaBfgPXzxtJJ=DZvC9ZjyfCTyaeHGWfeYA@mail.gmail.com&gt;
Feb  9 13:00:19 fenix postfix/qmgr[30796]: CF3EB61A7B: from=&lt;initiategnat9@gmail.com&gt;, size=4614, nrcpt=1 (queue active)
Feb  9 13:00:19 fenix postfix/local[31859]: CF3EB61A7B: to=&lt;debian@fenix.iesgn16.es&gt;, relay=local, delay=0.02, delays=0.01/0.01/0/0, dsn=2.0.0, status=sent (delivered to mailbox)
</code></pre><h2 id="uso-de-alias-y-redirecciones">Uso de alias y redirecciones</h2>
<ul>
<li><strong>Tarea 3:</strong></li>
</ul>
<p>Los procesos del sistema pueden mandar correos para informar sobre su estado. Por ejemplo, cuando se ejecuta una tarea de cron, podemos enviar un correo informando del resultado de la misma. Normalmente estos correos se mandan al usuario root, para hacer esto haremos lo siguiente:</p>
<pre><code>crontab -e

MAILTO = root
</code></pre><p>Podemos poner una tarea en el cron para ver c√≥mo se manda el correo.</p>
<pre><code>debian@fenix:~$ crontab -e

MAILTO = root

8 * * * * sudo apt-get update

sudo su

root@fenix:/home/debian# mail
&quot;/var/mail/root&quot;: 1 message 1 new
&gt;N   1 Cron Daemon        Tue Feb  9 19:08  24/894   Cron &lt;debian@fenix&gt; sudo apt-get update
? 1
Return-Path: &lt;debian@iesgn16.es&gt;
X-Original-To: root
Delivered-To: root@iesgn16.es
Received: by fenix.iesgn16.es (Postfix, from userid 1000)
        id 9E7D561A81; Tue,  9 Feb 2021 19:08:02 +0000 (UTC)
From: root@iesgn16.es (Cron Daemon)
To: root@iesgn16.es
Subject: Cron &lt;debian@fenix&gt; sudo apt-get update
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Cron-Env: &lt;MAILTO=root&gt;
X-Cron-Env: &lt;SHELL=/bin/sh&gt;
X-Cron-Env: &lt;HOME=/home/debian&gt;
X-Cron-Env: &lt;PATH=/usr/bin:/bin&gt;
X-Cron-Env: &lt;LOGNAME=debian&gt;
Message-Id: &lt;20210209190802.9E7D561A81@fenix.iesgn16.es&gt;
Date: Tue,  9 Feb 2021 19:08:02 +0000 (UTC)

Hit:1 http://security.debian.org/debian-security buster/updates InRelease
Hit:2 http://deb.debian.org/debian buster InRelease
Get:3 http://deb.debian.org/debian buster-updates InRelease [51.9 kB]
Fetched 51.9 kB in 0s (149 kB/s)
Reading package lists...
? q
Saved 1 message in /root/mbox
Held 0 messages in /var/mail/root
</code></pre><p>Posteriormente, usando alias y redirecciones podemos hacer llegar esos correos a nuestro correo personal.</p>
<pre><code>sudo su -

nano .forward

initiategnat9@gmail.com

exit
</code></pre><p><img src="/correo/5.png" alt="Captura 5"></p>
<p>Crea un nuevo alias para que los correos se manden a un usuario sin privilegios y comprueba que llegan a ese usuario.</p>
<pre><code>sudo nano /etc/aliases

postmaster:    root
usuario: debian

sudo newaliases

mail

&gt;N   1 Mail Delivery Syst Tue Feb  9 19:42  80/2679  Undelivered Mail Returned to Sender
</code></pre><h2 id="gesti√≥n-de-correos-desde-un-cliente">Gesti√≥n de correos desde un cliente</h2>
<ul>
<li><strong>Tarea 8:</strong></li>
</ul>
<p>Ahora vamos a configurar el buz√≥n de correos de cada usuario siendo de tipo <code>Maildir</code>, para ello vamos a modificar el fichero <code>/etc/postfix/main.cf</code> y comprobamos, mandando un correo, que se nos guardan en ese directorio.</p>
<pre><code>sudo nano /etc/postfix/main.cf

[...]
home_mailbox = Maildir/
mailbox_command =

sudo systemctl restart postfix

debian@fenix:~$ ls
Maildir

debian@fenix:~$ ls Maildir/
cur  new  tmp

debian@fenix:~$ ls Maildir/new/
1612941963.V801I20b38M9703.fenix
</code></pre><p><img src="/correo/6.png" alt="Captura 6"></p>
<p>Para abrir los correos de tipo maildir desde la terminal, no podemos hacer con mail, as√≥ que instalaremos la herramienta mutt y editamos el fichero <code>~/.muttrc</code></p>
<pre><code>sudo apt-get install muttrc

debian@fenix:~$ nano ~/.muttrc

set mbox_type=Maildir
set folder=&quot;~/Maildir&quot;
set mask=&quot;!^\\.[^.]&quot;
set mbox=&quot;~/Maildir&quot;
set record=&quot;+.Sent&quot;
set postponed=&quot;+.Drafts&quot;
set spoolfile=&quot;~/Maildir&quot;
mailboxes `echo -n &quot;+ &quot;; find ~/Maildir -maxdepth 1 -type d -name &quot;.*&quot; -printf &quot;+'%f' &quot;`
macro index c &quot;&lt;change-folder&gt;?&lt;toggle-mailboxes&gt;&quot; &quot;open a different folder&quot;
macro pager c &quot;&lt;change-folder&gt;?&lt;toggle-mailboxes&gt;&quot; &quot;open a different folder&quot;
macro index C &quot;&lt;copy-message&gt;?&lt;toggle-mailboxes&gt;&quot; &quot;copy a message to a mailbox&quot;
macro index M &quot;&lt;save-message&gt;?&lt;toggle-mailboxes&gt;&quot; &quot;move a message to a mailbox&quot;

macro compose A &quot;&lt;attach-message&gt;?&lt;toggle-mailboxes&gt;&quot; &quot;attach message(s) to this message&quot;
</code></pre><p>Ahora abrimos el mensaje</p>
<pre><code>mutt

1     Feb 10 juanan veintidi (2.2K) Prueba Maildir

Date: Wed, 10 Feb 2021 08:54:08 +0100
From: juanan veintidiecinueve &lt;initiategnat9@gmail.com&gt;
To: debian@fenix.iesgn16.es
Subject: Prueba Maildir

Este es un correo que se guardar√° en Maildir

--
*Fdo: Juan Antonio Reifs Ram√≠rez*

[image: Mailtrack]
&lt;https://mailtrack.io?utm_source=gmail&amp;utm_medium=signature&amp;utm_campaign=signaturevirality5&amp;&gt;
Remitente
notificado con
Mailtrack
&lt;https://mailtrack.io?utm_source=gmail&amp;utm_medium=signature&amp;utm_campaign=signaturevirality5&amp;&gt;
10/02/21
08:49:05
</code></pre><ul>
<li><strong>Tarea 9:</strong></li>
</ul>
<p>Ahora vamos a instalar dovecot para poder ofrecer el protocolo IMAP y lo configuraremos para ofrecer autentificaci√≥n y cifrado.</p>
<pre><code>sudo apt-get install dovecot-imapd
</code></pre><p>Para poder realizar el cifrado de la comunicaci√≥n, vamos a crear un certificado de LetsEncrypt para el dominio <code>mail.iesgn.es</code>. Para realizarlo instalaremos <code>certbot</code> as√≠ que seguimos los siguientes pasos</p>
<pre><code>sudo apt install snapd

sudo snap install core

sudo snap install core; sudo snap refresh core

sudo snap install --classic certbot

sudo ln -s /snap/bin/certbot /usr/bin/certbot
</code></pre><p>Cuando tengamos <code>certbot</code>instalado, generamos nuestro certificado</p>
<pre><code>sudo certbot certonly --standalone
</code></pre><p>Cuando se genere, se guardar√° en el directorio <code>/etc/letsencrypt/live/mail.iesgn16.es</code>. Ahora que lo tenemos todo listo, vamos a pasar a la configuraci√≥n de dovecot:</p>
<ol>
<li>Editamos el fichero <code>/etc/dovecot/conf.d/10-auth.conf</code> para habilitar el mecanismo de autentificaci√≥n</li>
</ol>
<pre><code>sudo nano /etc/dovecot/conf.d/10-auth.conf

disable_plaintext_auth = yes
[...]
auth_mechanisms = plain login
</code></pre><ol start="2">
<li>Configuramos el directorio Maildir y comentamos la configuraci√≥n mbox que viene predeterminada en dovecot</li>
</ol>
<pre><code>sudo nano /etc/dovecot/conf.d/10-mail.conf

mail_location = maildir:~/Maildir
[...]
#mail_location = mbox:~/mail:INBOX=/var/mail/%u
</code></pre><ol start="3">
<li>Descomentamos las siguientes l√≠neas para habilitar el imaps</li>
</ol>
<pre><code>sudo nano /etc/dovecot/conf.d/10-master.conf

service imap-login {
  inet_listener imap {
    port = 143
  }
  inet_listener imaps {
    port = 993
    ssl = yes
  }
[...]
unix_listener /var/spool/postfix/private/auth {
    mode = 0666
    user = postfix
    group = postfix
}
</code></pre><ol start="4">
<li>Por √∫ltimo configuramos nuestros certificados y reiniciamos dovecot</li>
</ol>
<pre><code>sudo nano /etc/dovecot/conf.d/10-ssl.conf

ssl = required
[...]
ssl_cert = &lt;/etc/letsencrypt/live/mail.iesgn16.es/cert.pem
ssl_key = &lt;/etc/letsencrypt/live/mail.iesgn16.es/privkey.pem

sudo systemctl restart dovecot
</code></pre><p>Podemos verificar la configuraci√≥n de nuestro dovecot con el comando <code>dovecot -n</code></p>
<p>Ahora vamos a hacer una prueba, para verificar que recibimos mensajes en nuestro Mailbox, para ello vamos a enviar un correo de prueba desde gmail</p>
<p><img src="/correo/7.png" alt="Captura 7"></p>
<pre><code>ls Maildir/new/
1613034771.V801I2154fM907367.fenix

mutt
1 N + Feb 11 juanan veintidi (2.2K) Prueba Maildir

Date: Thu, 11 Feb 2021 10:12:40 +0100
From: juanan veintidiecinueve &lt;initiategnat9@gmail.com&gt;
To: debian@iesgn16.es
Subject: Prueba Maildir

Este mensaje tiene que llegar a tu Maildir

--
*Fdo: Juan Antonio Reifs Ram√≠rez*

[image: Mailtrack]
&lt;https://mailtrack.io?utm_source=gmail&amp;utm_medium=signature&amp;utm_campaign=signaturevirality5&amp;&gt;
Remitente
notificado con
Mailtrack
&lt;https://mailtrack.io?utm_source=gmail&amp;utm_medium=signature&amp;utm_campaign=signaturevirality5&amp;&gt;
11/02/21
10:12:20
</code></pre><p>Por √∫ltimo, vamos a configurar un cliente de correo, en este caso ser√° Thunderbird:</p>
<ol>
<li>Iniciamos sesi√≥n</li>
</ol>
<p><img src="/correo/8.png" alt="Captura 8"></p>
<ol start="2">
<li>Configuramos manualmente</li>
</ol>
<p><img src="/correo/9.png" alt="Captura 9"></p>
<p>Como podemos ver, hemos recibido el mensaje que hemos enviado anteriormente</p>
<p><img src="/correo/10.png" alt="Captura 10"></p>
<ul>
<li><strong>Tarea 11:</strong></li>
</ul>
<p>Vamos a configurar postfix para que podamos enviar correos desde los clientes remotos. La conexi√≥n entre el cliente y el servidor debe de estar autentificada con SASL y usando dovecot y, adem√°s, debede estar cifrada. Para realizar este cifrado usaremos <code>SMTPS</code>, el cual usa el puerto 465.</p>
<p>Primero habilitamos SMTP-AUTH para permitir que los clientes se identifiquen a trav√©s del mecanismo de autentificaci√≥n SASL. Tambi√©n se debe usar TLS para cifrar el proceso de autenticaci√≥n, para ello ejecutamos las siguientes instrucciones para editar el fichero de configuraci√≥n de postfix.</p>
<pre><code>sudo postconf -e 'smtpd_sasl_type = dovecot'
sudo postconf -e 'smtpd_sasl_path = private/auth'
sudo postconf -e 'smtpd_sasl_local_domain ='
sudo postconf -e 'smtpd_sasl_security_options = noanonymous'
sudo postconf -e 'broken_sasl_auth_clients = yes'
sudo postconf -e 'smtpd_sasl_auth_enable = yes'
sudo postconf -e 'smtpd_recipient_restrictions = permit_sasl_authenticated,permit_mynetworks,reject_unauth_destination'
sudo postconf -e 'smtp_tls_security_level = may'
sudo postconf -e 'smtpd_tls_security_level = may'
sudo postconf -e 'smtp_tls_note_starttls_offer = yes'
sudo postconf -e 'smtpd_tls_loglevel = 1'
sudo postconf -e 'smtpd_tls_received_header = yes'
</code></pre><p>Ahora editamos el fichero <code>/etc/postfix/master.cf</code> y descomentamos las siguientes l√≠neas</p>
<pre><code>sudo nano /etc/postfix/master.cf
[...]
smtps     inet  n       -       y       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_reject_unlisted_recipient=no
  -o smtpd_client_restrictions=$mua_client_restrictions
  -o smtpd_helo_restrictions=$mua_helo_restrictions
  -o smtpd_sender_restrictions=$mua_sender_restrictions
  -o smtpd_recipient_restrictions=
  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject
  -o milter_macro_daemon_name=ORIGINATING
[...]
</code></pre><p>Por √∫ltimo a√±adimos nuestro certificado y nuestra clave privada al fichero <code>/etc/postfix/main.cf</code> y reiniciamos postfix</p>
<pre><code>sudo nano /etc/postfix/main.cf
[...]
smtpd_tls_cert_file=/etc/letsencrypt/live/mail.iesgn16.es/cert.pem
smtpd_tls_key_file=/etc/letsencrypt/live/mail.iesgn16.es/privkey.pem
[...]

sudo systemctl restart postfix
</code></pre><p>Ahora nos dirigimos a Thunderbird y modificamos los valores de SMTP
<img src="/correo/11.png" alt="Captura 11"></p>
<p>Para comprobar que funciona, vamos a enviar un correo desde Thunderbird hacia mi gmail personal
<img src="/correo/12.png" alt="Captura 12"></p>
<p><img src="/correo/13.png" alt="Captura 13"></p>
]]></content>
        </item>
        
        <item>
            <title>Bienvenidos a JuananBlog</title>
            <link>https://juanan219.github.io/posts/2021/02/bienvenidos-a-juananblog/</link>
            <pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/bienvenidos-a-juananblog/</guid>
            <description>Bienvenidos a mi nuevo sitio web est√°tico generado con HUGO.</description>
            <content type="html"><![CDATA[<p>Bienvenidos a mi nuevo sitio web est√°tico generado con HUGO.</p>
]]></content>
        </item>
        
        <item>
            <title>Generar Sitios Web est√°ticos con HUGO y GitHub Pages</title>
            <link>https://juanan219.github.io/posts/2021/02/generar-sitios-web-est%C3%A1ticos-con-hugo-y-github-pages/</link>
            <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
            
            <guid>https://juanan219.github.io/posts/2021/02/generar-sitios-web-est%C3%A1ticos-con-hugo-y-github-pages/</guid>
            <description>En esta pr√°ctica vamos a seleccionar una combinaci√≥n para realizar el depliegue de una web est√°tica y a√±adir contenido a ella, en mi caso, voy a seleccionar la combinaci√≥n de HUGO y GitHub Pages.
Para comenzar, vamos a instalar la herramientas necesarias para realizar esta pr√°ctica, as√≠ que instalaremos git y hugo
sudo apt-get update sudo apt-get install git hugo Cuando tengamos los paquetes descargados, vamos a comenzar a montar nuestro sitio y como vamos a subirlo a github, creamos un nuevo repositorio vac√≠o y lo clonamos a nuestro directorio de trabajo, para m√°s tarde comenzar a crear nuestro sitio</description>
            <content type="html"><![CDATA[<p>En esta pr√°ctica vamos a seleccionar una combinaci√≥n para realizar el depliegue de una web est√°tica y a√±adir contenido a ella, en mi caso, voy a seleccionar la combinaci√≥n de HUGO y GitHub Pages.</p>
<p>Para comenzar, vamos a instalar la herramientas necesarias para realizar esta pr√°ctica, as√≠ que instalaremos git y hugo</p>
<pre><code>sudo apt-get update

sudo apt-get install git hugo
</code></pre><p>Cuando tengamos los paquetes descargados, vamos a comenzar a montar nuestro sitio y como vamos a subirlo a github, creamos un nuevo repositorio vac√≠o y lo clonamos a nuestro directorio de trabajo, para m√°s tarde comenzar a crear nuestro sitio</p>
<pre><code>git clone git@github.com:Juanan219/JuananBlog.git

hugo new site --force JuananBlog/
</code></pre><p>Si queremos, ya podemos hacer el primer commit en github y comenzar a subir los archivos</p>
<pre><code>git add .

git commit -am &quot;Primer commit&quot;

git push
</code></pre><p>Ahora vamos a a√±adir un tema de los <a href="https://themes.gohugo.io/">temas de hugo</a>, para ello vamos a clonar el repositorio de uno de ellos en el directorio themes</p>
<pre><code>git clone git@github.com:rhazdon/hugo-theme-hello-friend-ng.git
</code></pre><p>En esta pr√°ctica no me voy a parar a adaptar el tema entero, as√≠ que coger√© el tema de ejemplo que viene en el directorio que hemos clonado y vamos a adaptarlo para que funcione</p>
<pre><code>cd ..

cp -r themes/hugo-theme-hello-friend-ng/exampleSite/* .
</code></pre><p>Cuando tengamos todos los archivos de ejemplo copiados al directorio principal de nuestro sitio, vamos a editar el config.toml para poner nuestros enlaces y nuestro nombre junto a la fecha actual</p>
<pre><code>nano config.toml
baseURL = &quot;https://juanan219.github.io&quot;
title   = &quot;JuananBlog&quot;
[...]
[author]
  name = &quot;Juan antonio Reifs&quot;
[...]
[params]
  dateform        = &quot;Feb 4, 2021&quot;
  dateformShort   = &quot;Feb 4&quot;
  dateformNum     = &quot;2021-02-04&quot;
  dateformNumTime = &quot;2021-02-04 11:35&quot;
[...]
description = &quot;Blog de Inform√°tica&quot;
[...]
homeSubtitle = &quot;Blog de Inform√°tica&quot;
[...]
[[params.social]]
    name = &quot;twitter&quot;
    url  = &quot;https://twitter.com/juanan219&quot;

  [[params.social]]
    name = &quot;email&quot;
    url  = &quot;mailto:initiategnat9@gmail.com&quot;

  [[params.social]]
    name = &quot;github&quot;
    url  = &quot;https://github.com/juanan219&quot;

  [[params.social]]
    name = &quot;linkedin&quot;
    url  = &quot;https://www.linkedin.com/in/juan-antonio-reifs-ram%C3%ADrez-b78b40162/&quot;

#  [[params.social]]
#    name = &quot;stackoverflow&quot;
#    url  = &quot;https://www.stackoverflow.com/&quot;
</code></pre><p>Ahora vamos a eliminar los posts de ejemplo y vamos a crear uno, pero al ejecutar el comando para crear un nuevo usuario me sal√≠a el siguiente error <code>Error: module &quot;hello-friend-ng&quot; not found;...</code> y para solucionarlo simplemente tuve que cambiar el nombre del tema y ya pude agregar un nuevo post.</p>
<pre><code>mv themes/hugo-theme-hello-friend-ng/ themes/hello-friend-ng

hugo new posts/Bienvenida.md

cd content/posts/

rm creating-a-new-theme.md  goisforlovers.fr.md  goisforlovers.md  hugoisforlovers.fr.md  migrate-from-jekyll.fr.md
</code></pre><p>Creamos un archivo <code>gitignore</code> para no subir la carpeta public que vamos a generar con el contenido html</p>
<pre><code>nano .gitignore

public/
</code></pre><p>Ahora que tenemos todo listo, vamos a crear un repositorio de github para github pages llamado juanan219.github.io y vamos a clonar dicho repositorio en nuestra m√°quina y vamos a generar dentro de √©l los archivos est√°ticos de hugo</p>
<pre><code>git clone git@github.com:Juanan219/juanan219.github.io.git

cd JuananBlog/

hugo -d ../juanan219.github.io/
</code></pre><p>Cuando hayamos generado todos los archivos vamos a subirlos al nuevo repositorio</p>
<pre><code>cd ../juanan219.github.io/

git add --all

git commit -am &quot;Archivos est√°ticos HUGO&quot;

git push
</code></pre><p>Por √∫ltimo, si nos dirigimos a la configuraci√≥n de nuestro nuevo repositorio de GitHub, si bajamos, podremos ver un apartado llamado GitHub Pages, en el cual, si todo ha salido bien, nos dir√° que nuestra p√°gina est√° subida a <a href="https://juanan219.github.io/">la url que le hemos configurado</a></p>
<p><img src="/web_estatica/1.PNG" alt="Captura 1"></p>
]]></content>
        </item>
        
    </channel>
</rss>
